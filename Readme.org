* Professional C++ Third Edition by Marc Gregoire
** Links
[[http://www.nuonsoft.com/blog/][Marc Gregoire's Blog]] |
[[http://www.cppreference.com][Cpp Reference (cppreference.com)]] |
[[http://www.cplusplus.com/reference/][Cpp Reference (cplusplus.com/reference)]] |
[[http://www.gnu.org][GNU Project]] |
[[http://www.opensource.org][Open Source Initiative]] |
[[http://www.boost.org][Open Source Boost Libraries]] |
[[http://www.sourceforge.net][Open Source Libraries]]

** Part I - Introduction to Professional C++
*** Chapter 01 - A Crash Course in C++ and the STL
**** Notes
- A function declaration tells the compiler how a function is called, declaring the number and types of
  parameters, and the function return type. A definition contains the actual code for the function. In C++,
  declarations usually go into files with extension =.h=, known as =header files=, while definitions usually
  go into files with extension =.cpp=, known as =source files=. A lot of other programming languages do not
  separate declarations and definitions into separate files, for example =C#= and =Java=.
- In =C=, header files usually end in =.h= as =<stdio.h>=. In =C++=, the suffix is ommitted for standard
  library headers, such as =<iostream>. Standard headers from =C= still exist in =C++=, but with new names.
  For example, you can access the functionality from =<stdio.h>= by including =<cstdio>=.
- Namespaces address the problem of naming conflicts between different pieces of code.
- Most compilers will issue a warning or an error when code is using uninitialized variables. Some compilers
  will generate code that will report and error at run time.
- C++ does not provide a basic string type. However, a standard implementation of a string is provided as part
  of the standard library.
- Both C-style arrays and the =std::array=s have a fixed size, which should be known at compile time. They
  cannot grow or shrink at run time.
- Function declarations are often called "function prototypes" or "signatures" to emphasize that they
  represent how the function can be accessed, but not the code behind it.
- In C++, unlike C, a function that takes no parameters just has an empty parameter list. It is not necessary
  to use =void= to indicate that no parameters are taken. However, you must still use =void= to indicate when
  no value is returned.
- Avoid using =malloc()= and =free()= from C. Instead, use =new= and =delete=, or =new[]= and =delete[]=.
- Naked, plain old pointers are only allowed if there is no ownership involved. Otherwise, use =unique_ptr= by
  default, and =shared_ptr= if you need shared ownership. If you know about =auto_ptr=, forget it because the
  C++ standard has deprecated it.
- In C++ a class defines the characteristics of an object. Classes are usually defined in a header file
  (=.h=), while the definitions of its non-inline methods and of any static data members is in a corresponding
  source file (=.cpp=).
- To follow the const-correctness principle, it's always a good idea to declare member functions that do not
  change any data member of the object as being =const=. These member functions are also called "inspectors,"
  compared to "mutators" for non-const member functions.

**** Warnings
- Never put a =using= directive or =using= declaration in a header file, otherwise you force it on everyone
  that is including your header.
- In C++, the first element of an array is always at position 0, not position 1! The last position of the
  array is always the size of the array minus 1!
- A pointer must be valid before dereferencing it. A =null= or uninitialized pointer will cause a crash if
  dereferenced.
- To prevent memory leaks, every call to =new= should be paired with a call to =delete=, and every call to
  =new[]= should be paired with a call to =delete[]=. Pairing a =new[]= with a =delete= also causes a memory
  leak.

*** Chapter 02 - Working with Strings
**** Notes
- C++ provides a much-improved implementation of the concept of a string as part of the Standard Library. In
  C++, =std::string= is a class (actually an instantiation of the =basic_string= class template) that supports
  many of the same functionalities as the =<cstring>= functions, but takes care of memory allocation for you.
  The string class is defined in the =<string>= header in the =std= namespace.
- Raw string literals are string literals that can span across multiple lines of code, that don't require
  escaping of embedded double quotes, and where escape sequences like =\t= and =\n= are not processed as
  escape sequences, but as normal text.

**** Warnings
- When starting a project in C++, it is very important to decide ahead of time how your group will represent
  strings.

*** Chapter 03 - Coding with Style
**** Notes
- Commenting every line of code is usually untenable, but if the code is complicated enough to require it,
  don't just translate the code to English: explain what's really going on.
- Good code is naturally readable and only requires comments to provide useful additional information.
- Language features exist to help the programmer. Understand and make use of features that contribute to good
  programming style.

** Part II - Professional C++ Software Design
*** Chapter 04 - Designing Professional C++ Programs
**** Notes
- The point of designing is to think about your program before you write it.
- Keep in mind that good design is hard, and getting it right takes practice. Don't expect to become an expert
  overnight, and don't be surprised if you find it more difficult to master C++ design than C++ coding.
- A program uses a library but fits into a framework. Libraries provide specific functionality, while
  frameworks are fundamental to your program design and structure.
- Although people use the terms API and library interchangeably, they are not equivalent. The library refers
  to the implementation, while the API refers to the published interface to the library.
- Big-O notation applies only to algorithms whose speed depends on their inputs. It does not apply to
  algorithms that take no input or whose runnign time is random. In practice, you will find that the running
  times of most algorithms of interest depend on their input, so this limitation is not significant.

**** Warnings
- Make sure that you understand the license restrictions of any third-party libraries you use if you plan to
  distribute or sell the code you develop. When in doubt, consult a legal expert.
- Due to time constraints, programmers sometimes find their prototypes morphing into the final product. If you
  have hacked together a prototype that is insufficient as the basis for the final product, make sure that it
  doesn't get used way.

*** Chapter 05 - Designing with Objects
**** Notes
- Unlike the procedural approach, which is based on the question What does this program do?, the
  object-oriented approach asks another question: What real-world objects am I modeling? =OOP= is based on the
  notion that you should divide your program not into tasks, but into models of physical objects. While this
  seems abstract at first, it becomes clearer when you consider physical objects in terms of their =classes=,
  =components=, =properties=, and =behaviors=.
- The =Has-A Relationship=: Objects engaged in a =has-a=, or =aggregation=, relationship follow the pattern A
  has a B, or A contains a B. In this type of relationship, you can envision one object as part of another.
  Components generally represent a has-a relationship because they describe objects that are made up of other
  objects.
- The =Is-A Relationship= (Inheritance): The is-a relationship is such a fundamental concept of
  object-oriented programming that it has many names, including deriving, subclassing, extending, and
  inheriting. Classes model the fact that the real world contains objects with properties and behaviors.
  Inheritance models the fact that these objects tend to be organized in hierarchies. These hierarchies
  indicate is-a relationships. Fundamentally, inheritance follows the pattern A is a B or A is really quite a
  bit like B.
- A good object-oriented hierarchy accomplishes the following:
  - Organizes classes into meaningful functional relationships.
  - Supports code reuse by factoring common functionality to base classes.
  - Avoid having derived classes that override much of the parent's functionality, unless the parent is an
    abstract class.

*** Chapter 06 - Designing for Reuse
**** Notes
- Unfortunately, C++ is fundamentally unfriendly to the principle of good abstraction when writing classes.
  The syntax requires you to combine your public interfaces and non-public (private or protected) data members
  and methods together in one class definition, thereby exposing some of the internal implementation details
  of the class to its clients. Chapter 8 describes some techniques for working around this in order to present
  clean interfaces.
- Always think about your interfaces from the perspective of someone using them. Do they make sense? Are they
  what you would expect?

***** Structuring your code
- Avoid combining unrelated or logically separate concepts: When you design a library or framework, keep it
  focused on a single task or group of tasks, i.e., strive for high cohesion.
- Divide your programs into logical subsystems: Design your subsystems as discrete components that can be
  reused independently, i.e., strive for low coupling.
- Use class hierarchies to separate logical concepts: In addition to dividing your program into logical
  subsystems, you should avoid combining unrelated concepts at the class level. You should also avoid
  combining unrelated concepts at the level of methods, just as you should do at the class level. Both at the
  class level and the method level you should strive for high cohesion.
- Use aggregation to separate logical concepts: Aggregation models the has-a relationship: Objects contain
  other objects to perform some aspects of their functionality. You can use aggregation to separate unrelated
  or related but separate functionality when inheritance is not appropriate.
- Eliminate user interface dependencies: If your library is a data manipulation library, you want to separate
  data manipulation from the user interface. This means that for those kinds of libraries you should never
  assume in which type of user interface the library will be used. As such, do not use =cout=, =cerr=, =cin=,
  =stdout=, =stderr=, or =stdin=, because if the library is used in the context of a graphical user interface
  these concepts may make no sense.
- Use templates for generic data structures and algorithms: C++ has a concept called templates allowing you to
  create structures that are generic with respect to a type or class. The notion of a template is that the
  type becomes a parameter to the specification, and you can create a single body of code that can work on any
  type. Templates allow you to write both data structures and algorithms that work on any types.
- Provide appropriate checks and safeguards: There are two opposite styles for writing safe code. The optimal
  programming style is probably using a healthy mix of both of them. The first is called design-by-contract
  which means that the documentation for a function or a class represents a contract with a detailed
  description of what the responsibility of the client code is and what the responsibility of your function or
  class is. This is often used in the =STL=. The second style is that you design your functions and classes to
  be as safe as possible. The most important aspect of this guideline is to perform error checking in your
  code.

***** Designing Interfaces
- Develop Easy-To-Use Interfaces: The best strategy for developing easy-to-use interfaces is to follow
  standard and familiar ways of doing things. When people encounter an interface similar to something they
  have used in the past, they will understand it better, adopt it more readily, and be less likely to use it
  improperly. Applied to C++, this strategy implies that you should develop interfaces that follow standards
  to which C++ programmers are accustomed. For example, C++ programmers expect the =constructor= and
  =destructor= of a class to initialize and clean up an object, respectively. When you design your classes,
  you should follow this standard. If you require programmers to call =initialize()= and =cleanup()= methods
  for initialization and cleanup instead of placing that functionality in the =constructor= and =destructor=,
  you will confuse everyone who tries to use your class. Because your class behaves differently from other C++
  classes, programmers will take longer to learn how to use it and will be more likely to use it incorrectly
  by forgetting to call =initialize()= or =cleanup()=.
- Don't omit required functionality: First, include interfaces for all behaviors that clients could need. This
  strategy requires you to anticipate all the uses to which clients might put your code. If you are thinking
  about the interface in one particular way, you might miss functionality that could be needed when clients
  use it differently. The second part of this strategy is to include as much functionality in the
  implementation as possible. Don't require client code to specify information that you already know in the
  implementation, or could know if you designed it differently.
- Present uncluttered interfaces: Don't provide unnecessary functionality in your interfaces; keep them clean
  and simple. It might appear at first that this guideline directly contradicts the previous strategy of
  avoiding omitting necessary functionality. Although one strategy to avoid omitting functionality would be to
  include every imaginable interface, that is not a sound strategy. You should include necessary functionality
  and omit useless or counterproductive interfaces.
- Provide documentation and comments: Regardless of how easy to use you make your interfaces, you should
  supply documentation for their use. There are two ways to provide documentation for your interfaces:
  comments in the interfaces themselves and external documentation. You should strive to provide both. Whether
  you provide comments, external documentation, or both, the documentation should describe the behavior of the
  library, not the implementation. The behavior includes the inputs, outputs, error conditions and handling,
  intended uses, and performance guarantees.
- Provide multiple ways to perform the same functionality: In order to satisfy all your "customers," it is
  sometimes helpful to provide multiple ways to perform the same functionality. Use this technique
  judiciously, however, because over application can easily lead to cluttered interfaces.
- Provide customizability: In order to increase the flexibility of your interfaces, provide customizability.
  Customizability can be as simple as allowing a client to turn on or off error logging. The basic premise of
  customizability is that it allows you to provide the same basic functionality to every client, but gives
  clients the ability to tweak it slightly.
- Make common functionality easy to use: When you provide a general-purpose interface, some functionality will
  be used more often than other functionality. You should make the commonly used functionality easy to use,
  while still providing the option for the more advanced functionality.

**** Warnings
- When designing your interface, do not expose implementation details to your clients.

** Part III - Coding The Professional Way
*** Chapter 07 - Gaining Proficiency with Classes and Objects
**** Notes
- A =class definition= is a statement in C++, so it must end with a semicolon. If you fail to terminate your
  =class definition= with a semicolon, your compiler will probably give you several errors, most of which will
  appear to be completely unrelated.
- A =class= can have a number of members. A member is either a member function (which in turn is either a
  method, constructor, or destructor), or a member variable also called data member.
- In C++, a =struct= can have methods just like a =class=. In fact, the only difference is that the default
  access specifier for a =struct= is =public= while the default for a =class= is =private=.
- Every normal method call passes a pointer to the object for which it is called as a "hidden" parameter with
  the name =this=. You can use this pointer to access data members or call methods, and can pass it to other
  methods or functions. It is also sometimes useful for disambiguating names. if =this= is a pointer to the
  object on which a method executes, then =*this= is the object itself!
- If you don't use =smart pointers=, it is always a good idea to reset a pointer to the =null pointer= after
  deleting the object to which it pointed. You are not required to do this, but it will make debugging easier
  in case the pointer is accidentally used after deleting the object.
- The object life cycle involves three activities: creation, destruction, and assignment. It is important to
  understand how and when objects are created, destroyed, and assigned, and how you can customize these
  behaviors.
- C++ supports delegating constructors which allow you to call other constructors from the same class from
  inside the =ctor-initializer=.
- There is a special constructor in C++ called a copy constructor that allows you to create an object that is
  an exact copy of another object. If you don't write a copy constructor yourself, C++ generates one for you
  that initializes each data member in the new object from its equivalent data member in the source object.
  For object data members, this initialization means that their copy constructors are called.
- For performance reasons, it is best to pass objects by =const= reference instead of by value.
- The assignment operator is sometimes called the copy assignment operator because both the left-hand side and
  the right-hand side object stay alive after the assignment. This distinction is made because there is also a
  move assignment operator in which the right-hand side object will be destroyed after the assignment for
  performance reasons.
- In the world of C++, "copying" only occurs when an object is being initialized. If an object already has a
  value that is being overwritten, the more accurate term is "assigned" to. Note that the facility that C++
  provides for copying is the copy constructor. Since it is a constructor, it can only be used for object
  creation, not for later assignments to the object. Therefore, C++ provides another method in every class to
  perform assignment. This method is called the assignment operator. Its name is operator= because it is
  actually an overloading of the = operator for that class.
- The implementation of the assignment operator is similar to that of a copy constructor, with several
  important differences. First, a copy constructor is called only for initialization, so the destination
  object does not yet have valid values. An assignment operator can overwrite the current values in an object.
  This consideration doesn't really come into play until you have dynamically allocated memory in your
  objects. Second, it's legal in C++ to assign an object to itself. Your assignment operator shouldn't
  prohibit self-assignment, but also shouldn't perform a full assignment if it happens. Thus, assignment
  operators should check for self-assignment at the beginning of the method and return immediately.

**** Warnings
- If you allocate an object with =new=, free it with =delete= when you are finished with it, or use =smart
  pointers= to manage the memory automatically.
- When creating an object on the stack, omit parentheses for the default constructor.
- If you don't specify any constructors, the compiler will write one for you that doesn't take any arguments.
  This =compiler-generated default constructor= calls the default constructor on all object members of the
  class, but does not initialize the language primitives such as =int= and =double=. Nonetheless, it allows
  you to create objects of that class. However, if you declare a default constructor, or any other
  constructor, the compiler no longer generates a default constructor for you.
- A =default constructor= is the same thing as a 0-argument constructor. The term =default constructor= does
  not refer only to the constructor automatically generated if you fail to declare any constructors. It refers
  to the constructor which is defaulted to if no arguments are required.
- Ctor-initializers allow initialization of data members at the time of their creation. Ctor-initializers
  initialize data members in the order that they appear in the class definition, not their order in the
  ctor-initializer.
- Make sure you always free dynamically allocated memory by calling =delete= or =delete[]= depending on
  whether the memory was allocated using =new= or =new[]= or better yet, use smart pointers.
- You could actually declare the assignment operator to return whatever type you wanted, including =void=.
  However, you should always return a reference to the object on which it is called because that's what
  clients expect.

*** Chapter 08 - Mastering Classes and Objects
**** Notes
- Whenever you are finished with dynamically allocated memory, you should free it. If you dynamically allocate
  memory in an object, the place to free that memory is in the destructor. The compiler guarantees that the
  destructor will be called when the object is destroyed. Normally the destructor frees the memory that was
  allocated in the constructor. However, no rule requires you to free memory in the destructor. You can write
  whatever code you want in the destructor, but it is a good idea to use it only for freeing memory or
  disposing of other resources.
- In assignment operators you must first free the memory referenced by the left-hand side, and then do a deep
  copy. You can think of an assignment operator as a combination of a destructor and a copy constructor. You
  are essentially "reincarnating" the object with new life (or data) when you assign to it.
- Next to copying, C++ also supports move semantics, which requires a move constructor and move assignment
  operator. These can be used to increase performance in certain situations.
- Sometimes when you dynamically allocate memory in your class, it's easiest just to prevent anyone from
  copying or assigning to your objects. You can do this by explicitly deleting your operator= and copy
  constructor. That way, if anyone tries to pass the object by value, return it from a function or method, or
  assign to it, the compiler will complain. If your compiler doesn't support explicitly deleting member
  functions, then you can disallow copying and assigning by making your copy constructor and assignment
  operator private without any implementation.
- C++ gives you many choices for data members. In addition to declaring simple data members in your classes,
  you can create =static= data members that all objects of the class share, =const= members, =reference=
  members, =const reference= members, and more.
- Data members in your class can be declared =const=, meaning they can't be changed after they are created and
  initialized. You should use =static const= data members in place of global constants when the constants
  apply only to the class.
- Destructors will not be called when you thrown an exception from a constructor. Be carefull!
- Non-static data members can also be declared =const=. Since you cannot assign to a =const= data member, you
  need to initialize them in your =ctor-initializers=.
- A reference cannot exist without referring to something, so a reference data member must be given a value in
  the =ctor-initializer= of the constructor. Remember that after you have initialized a reference you cannot
  change the object to which it refers. It's not possible to assign to references in the assignment operator.
- There is an important difference between using a =const reference= versus a =non-const reference=. The
  =const reference= data member can only be used to call =const= methods on the object. If you try to call a
  =non-const= method through a =const reference=, you will get a compiler error.
- A =const= object is an object whose value cannot be changed. If you have a =const=, reference to =const= or
  pointer to =const= object, the compiler will not let you call any methods on that object unless those
  methods guarantee that they won't change any data members. The way you guarantee that a method won't change
  data members is to mark the method itself with the =const= keyword. A =non-const= object can call =const=
  and =non-const= methods. However, a =const= object can only call =const= methods. You should get into the
  habit of declaring =const= all methods that don't modify the object so that you can use references to
  =const= objects in your program.
- Sometimes you write a method that is "logically" =const= but happens to change a data member of the object.
  This modification has no effect on any user-visible data, but is technically a change, so the compiler won't
  let you declare the method =const=. The solution to this is to declare the data member variable =mutable=,
  which tells the compiler that it's okay to change it in a =const= method.
- Note also that you can overload a method based on =const=. That is, you can write two methods with the same
  name and same parameters, one of which is declared =const= and one of which is not. The compiler will call
  the =const= method if you have a =const= object and the =non-const= method if you have a =non-const= object.
- Class definitions can contain more than just member functions and data members. You can also write nested
  classes and =structs=, declare =typedefs=, or create enumerated types. Anything declared inside a class is
  in the scope of that class. If it is =public=, you can access it outside the class by scoping it with the
  =ClassName::= scope resolution syntax.
- If you want to define a number of constants inside a class, you should use an enumerated type instead of a
  collection of =#defines=.
- C++ allows classes to declare that other classes, or member functions of other classes, or nonmember
  functions are =friends=, and can access =protected= and =private= data members and methods. =friend= classes
  and methods are easy to abuse; they allow you to violate the principle of encapsulation by exposing
  internals of your class to other classes or functions. Thus, you should use them only in limited
  circumstances such as operator overloading because in that case you need access to =protected= and =private=
  members.
- In C++, you cannot change the precedence of operators. For example, =*= and =/= are always evaluated before
  =+= and =-=. The only thing user-defined operators can do is specify the implementation once the precedence
  of operations has been determined. C++ also does not allow you to invent new operator symbols.
- Most of the time, performing equality or inequality tests on floating point values is not a good idea. You
  should use an epsilon test, but this falls outside the scope of this book.
- Provide operator overloading as a service to clients of your class.

**** Warnings
- Whenever you have dynamically allocated memory in a class, you should write your own copy constructor and
  assignment operator to provide a deep copy of the memory.
- Whenever a class dynamically allocates memory, write a destructor, copy constructor, and assignment
  operator.

*** Chapter 09 - Discovering Inheritance Techniques
**** Notes
- When you write a class definition in C++, you can tell the compiler that your class is inheriting from, or
  extending, an existing class. By doing so, your class will automatically contain the data members and
  methods of the original class, which is called the parent class or base class or superclass. Extending an
  existing class gives your class (which is now called a derived class or a subclass) the ability to describe
  only the ways in which it is different from the parent class.
- From the perspective of other code, an object belongs to its defined class as well as to any base classes.
- The private access specifier gives you control over how a potential derived class could interact with your
  class. I recommend that you make all your data members private by default. You can provide public getters
  and setters if you want to allow anyone to access those data members, and you can provide protected getters
  and setters if you only want derived classes to access them. The reason to make data members private by
  default is that this provides the highest level of encapsulation. This means that you can change how you
  represent your data while keeping the public and protected interface unchanged. Without giving direct access
  to data members, you can also easily add checks on the input data in your public and protected setters.
  Methods should also be private by default. Only make those methods public that are designed to be public,
  and make methods protected if you only want derived classes to have access to them.
- C++ allows you to mark a class as =final=, which means trying to inherit from it will result in a compiler
  error. Also, C++ allows you to mark a method as =final= which means that the method cannot be overridden in
  a derived class.
- There is one small twist to overriding methods in C++ and it has to do with the keyword =virtual=. Only
  methods that are declared as =virtual= in the base class can be overridden properly by derived classes.
- As a rule of thumb, make all your methods =virtual= (including the destructor, but not constructors) to
  avoid problems associated with omission of the =virtual= keyword.
- Derived classes retain their overridden methods when referred to by base class pointers or references. They
  lose their uniqueness when cast to a base class object. The loss of overridden methods and derived class
  data is called slicing.
- An abstract class provides a way to prevent other code from instantiating an object directly, as opposed to
  one of its derived classes.
- When overriding from a parent class, a good rule of thumb is to override a method with the exact method
  declaration, or method prototype, that the base class uses. The implementation can change, but the prototype
  stays the same. That does not have to be the case, however. In C++, an overriding method can change the
  return type as long as the original return type is a pointer or reference to a class, and the new return
  type is a pointer or reference to a descendent class. Such types are called =covariant return types=. This
  feature sometimes comes in handy when the base class and derived class work with objects in a parallel
  hierarchy. That is, another group of classes that is tangential, but related, to the first class hierarchy.
  A good way to figure out whether you can change the return type of an overridden method is to consider
  whether existing code would still work, the Liskov substitution principle (LSP).
- It is rare to find a method in a derived class with the same name as a method in the base class but using a
  different parameter list.
- =static= methods are scoped by the name of the class in which they are defined, but are not methods that
  apply to a specific object. A method in a class that calls a =static= method calls the version determined by
  normal name resolution. When called syntactically by using an object, the object is not actually involved in
  the call, except to determine the type at compile time.
- When overriding a method that has a default argument, you should provide a default argument as well, and it
  should probably be the same value. It is recommended to use a symbolic constant for default values so that
  the same symbolic constant can be used in derived classes.
- There is no reasonable way (or good reason) to restrict access to a =public= parent method.
- The only truly useful way to change a method's access level is by providing a less restrictive accessor to a
  =protected= method.
- Relative to other object-oriented languages, C++ is very compile-time oriented. Overriding methods works
  because of a level of indirection between a method and its implementation, not because the object has
  built-in knowledge of its own class.
- If you are using =typeid= other than for logging and debugging purposes, consider re-implementing it using
  =virtual= methods.
- Non-public inheritance is rare and I recommend using it cautiously, if for no other reason than because most
  programmers are not familiar with it.
- Virtual base classes are a great way to avoid ambiguity in class hierarchies. The only drawback is that many
  C++ programmers are unfamiliar with the concept.

**** Warnings
- Virtual methods behave differently in constructors. If your derived class has overridden a virtual method
  from the base class, calling that method from a base class constructor will call the base class
  implementation of that virtual method and not your overridden version in the derived class.
- Always make your destructors =virtual=. The compiler generated default destructor is not =virtual=, so you
  should define your own =virtual= destructor, at least for your parent classes.
- Just as with constructors, virtual methods behave differently when called from a destructor. If your derived
  class has overridden a virtual method from the base class, calling that method from the base class
  destructor will call the base class implementation of that virtual method and not your overridden version in
  the derived class.
- When upcasting, use a pointer or reference to the base class to avoid slicing.
- Use downcasting only when necessary and be sure to use =dynamic_cast=.
- You can always cast up the hierarchy, and you can sometimes cast down the hierarchy. Casting across the
  hierarchy is possible by changing the behavior of the cast operator, or by using =reinterpret_cast=, which
  is not recommended.
- To avoid obscure bugs, you should override all versions of an overloaded method, either explicitly or with
  the =using= keyword, but keep the risks of the =using= clause in mind.
- Overriding =private= and =protected= methods is a good way to change certain features of a class without a
  major overhaul.
- If your derived class does not specify its own copy constructor or ~operator=~, the parent functionality
  continues to work. If the derived class does provide its own copy constructor or ~operator=~, it needs to
  explicitly reference the parent versions.
- Attempting to override a non-virtual method will hide the base class definition and will only be used in the
  context of the derived class.
- Unless you have a specific reason not to, or the class is marked as =final=, I recommend making all methods,
  including destructors but not constructors, =virtual=. Constructors cannot and need not be =virtual= because
  you always specify the exact class being constructed when creating an object.
- The =typeid= operator only works correctly if the class has at least one =virtual= method. Using
  =dynamic_cast= on a class without any =virtual= method will cause a compiler error.

*** Chapter 10 - C++ Quirks, Oddities, and Incidentals
**** Notes
- Using =rvalue= references, it is possible to pass constants as arguments to functions that employ
  =pass-by-rvalue-reference=.
- You should use =pass-by-value= only for simple built-in types like ~int~ and ~double~ for which you don't
  need to modify the arguments. Use =pass-by-reference= in all other cases.
- Use references instead of pointers unless you need to change to where the reference refers to.
- An easy-to-remember rule to figure out complicated variable declarations: read from right to left. Take for
  example ~int* const ip~. Reading this from right to left gives us =ip is a const pointer to an int=. On the
  other hand, ~const int* ip~ will read as =ip is a pointer to a const int=.
- Avoid using stand-alone ~static~ variables. Maintain state within an object instead.
- C++14 defines the following standard user-defined literals:
  * "s" for creating ~std::string~; for example: ~auto myString = "Hello World"s;~
  * "h", "min", "s", "ms", "us", "ns", for creating ~std::chrono::duration~ time intervals,
    for example: ~auto myDuration = 42min~;
  * "i", "il", "if", for creating complex numbers ~complex<double>, complex<long double>~, and
    ~<complex<float>~ respectively; for example: ~auto myComplexNumber = 1.3i~;
- It's recommended to use forward declarations as much as possible in your header files instead of including
  other headers. This can reduce your compilation and recompilation times, because it breaks dependencies of
  your header file on other headers. Of course, your implementation file needs to include the correct headers
  for types that you've forward-declared, otherwise it won't compile.

**** Warnings
- You must always initialize a reference when it is created. Usually, references are created when they are
  declared, but reference data members need to be initialized in the constructor initializer for the
  containing class.
- You cannot change the variable to which a reference refers after it is initialized; you can change only the
  value of that variable.
- From a function or method, never return a reference to a variable that is locally scoped to that function or
  method, such as an automatically allocated variable on the stack that will be destroyed when the function
  ends.
- Your default choice for passing objects as parameters should be ~const reference~. You should only omit
  ~const~ if you explicitly need to change the object.
- Initialization order of non-local variables in different source files is undefined.
- In theory, you could also use ~reinterpret_cast~ to cast pointers to ~ints~ and ~ints~ to pointers, but this
  is considered erroneous programming, because on many platforms (especially 64-bit platforms) pointers and
  ~ints~ are of different sizes. For example, on a 64-bit platform, pointers are 64 bit, but integers could be
  32 bits. Casting a 64-bit pointer to a 32-bit integer will result in losing 32 critical bits!
- Avoid using C-style variable-length argument lists. It is preferable to pass in an ~std::array~ or
  ~std::vector~ of values, to use =initializer lists=, or to use =variadic templates= for type-safe
  variable-length argument lists.
- Avoid old C-style pre-processor macros entirely in favor of inline functions.

*** Chapter 11 - Writing Generic Code with Templates
**** Notes
- Functions parameterize values. Templates take the concept of parameterization a step further to allow you to
  parameterize on types as well as values. Just as you use parameter names in functions to represent the
  arguments that the caller will pass, you use template parameter names (such as ~T~) in templates to
  represent the types that the caller will specify.
- Class templates define a class where the types of some of the variables, return types of methods, and/or
  parameters to the methods are specified as parameters. Class templates are useful primarily for containers,
  or data structures, that store objects.
- In C++, you can write class templates, which allows you to write a class without specifying one or more
  types. Clients then instantiate the template by specifying the types they want to use. This is called
  generic programming. The biggest advantage of generic programming is type safety. The types used in the
  class and its methods are concrete types, and not abstract base classes types as is the case with
  polymorphic solutions.
- For historical reasons, you can use the keyword ~class~ instead of ~typename~ to specify template type
  parameters. Thus, many books and existing programs use syntax like this: ~template <class T>~. However, the
  use of the word "class" in this context is confusing because it implies that the type must be a class, which
  is not true. The type can be a ~class~, a ~struct~, a ~union~, a primitive type of the language like ~int~
  or ~double~, and so on.
- The ~template <typename T>~ specifier must precede each method definition for a class template.
- Templates require you to put the implementation of the methods in the header file itself, because the
  compiler needs to know the complete definition, including the definition of methods, before it can create an
  instance of the template.
- Normally you put class definitions in a header file and method definitions in a source file. Code that
  creates or uses objects of the class ~#includes~ the header file and obtains access to the method code via
  the linker. Templates don't work that way. Because they are "templates" for the compiler to generate the
  actual methods for the instantiated types, both class template definitions and method definitions must be
  available to the compiler in any source file that uses them. There are several mechanisms to obtain this
  inclusion.
  * Template Definitions in Header Files. You can place the method definitions directly in the same header
    file where you define the class itself. When you ~#include~ this file in a source file where you use the
    template, the compiler will have access to all the code it needs.
  * Template Definitions in a Separate Header File. Alternatively, you can place the template method
    definitions in a separate header file that you ~#include~ in the header file with the class definitions.
    Make sure the ~#include~ for the method definitions follows the class definition; otherwise the code won't
    compile.
  * Template Definitions in Source Files. Method implementations look strange in header files. If that syntax
    annoys you, there is a way that you can place the method definitions in a source file. However, you still
    need to make the definitions available to the code that uses the templates, which you can do by
    ~#includeing~ the method implementation source file in the class template definition header file. That
    sounds odd if you've never seen it before, but it's legal in C++. When using this technique, make sure you
    don't add the source file to your project, because it is not supposed to be, and cannot be compiled
    separately; it should be ~#included~ only in a header file.
  * Limit Class Template Instantiations. If you want your class templates to be used only with certain known
    types, you can use the this technique also called "Explicit Instantiation". With this technique, you
    disallow client code from using your class template with other types that you don't explicitly
    instantiate.
- Non-type template parameters become part of the type specification of instantiated objects.
- C++ allows you to templatize individual methods of a class. These methods can be inside a class template or
  in a non-templatized class. When you write a templatized class method, you are actually writing many
  different versions of that method for many different types. Method templates come in useful for assignment
  operators and copy constructors in class templates. Virtual methods and destructors cannot be method
  templates.
- Alternate implementations of templates are called template specializations. You might find the syntax to be
  a little weird. When you write a class template specialization, you must specify that it's a template, and
  that you are writing the version of the template for that particular type.
- Class template specialization allows you to write a special implementation for a template with the template
  types replaced by specific types. Keep in mind that there is also a more advanced feature of specialization
  called partial specialization.
- When you specialize a template, you don't "inherit" any code: Specializations are not like derivations. You
  must rewrite the entire implementation of the class. There is no requirement that you provide methods with
  the same names or behavior. As a matter of fact, you could write a completely different class with no
  relation to the original. Of course, that would abuse the template specialization ability, and you shouldn't
  do it without good reason.
- You can inherit from class templates. If the derived class inherits from the template itself, it must be a
  template as well. Alternatively, you can derive from a specific instantiation of the class template, in
  which case your derived class does not need to be a template.
- Use inheritance for extending implementations and for polymorphism. Use specialization for customizing
  implementations for particular types.
- You can also write templates for stand-alone functions. Like class template method definitions, function
  template definitions (not just the prototypes) must be available to all source files that use them. Thus,
  you should put the definitions in header files if more than one source file uses them.

*** Chapter 12 - Demystifying C++ I/O
**** Notes
- Every input stream has an associated source. Every output stream has an associated destination.
- If you get confused between ~<< and >>~, just think of the angles as pointing toward their destination. In
  an output stream, ~<<~ points toward the stream itself because data is being sent tho the stream. In an
  input stream, ~>>~ points toward the variables because data is being stored.
- You can use the ~<<~ operator to output a C++ string even though it is not a basic type. In C++, objects are
  able to prescribe how they are output and input. This is accomplished by overloading the ~<< and >>~
  operator to understand a new type or class.
- The ~ostringstream~ class is used to write data to a string, while the ~istringstream~ class is used to read
  data from a string. They are both defined in the ~<sstream>~ header file. Because ~ostringstream~ and
  ~istringstream~ inherit the same behavior as ~ostream~ and ~istream~, working with them is pleasantly
  similar.
- Tuning an object into a "flattened" type, like a string, is often called marshalling. Marshalling is useful
  for saving objects to disk or sending them accross a network.
- The main advantage of a string stream over a standard C++ string is that, in addition to data, the object
  knows where the next read or write operation will take place, also called current position. There may also
  be performance benefits depending on the particular implementation of string streams. For example, if you
  need to append a lot of strings together, it might be more efficient to use a string stream, instead of
  repeatedly calling the ~+=~ operator on a string object.
- Files lend themselves very well to the stream abstraction because reading and writing files always involves
  a position in addition to the data. In C++, the ~ofstream~ and ~ifstream~ classes provide output and input
  functionality for files. They are defined in the ~<fstream>~ header file.
- The ~seek()~ and ~tell()~ methods are present on all input and output streams, but they rarely make sense
  outside of the context of file streams. The ~seek()~ methods let you move to an arbitrary position within an
  input or output stream. There are several forms of ~seek()~. The methods of ~seek()~ within an input stream
  are actually called ~seekg()~ (the g is for get), and the versions of ~seek()~ in an output stream are
  called ~seekp()~ (the p is for put). You might wonder why there is both a ~seekg()~ and a ~seekp()~ method,
  instead of one ~seek()~ method. The reason is that you can have streams that are both input and output, for
  example, file streams. In that case, the stream needs to remember both a read position and a separate write
  position. This is also called bidirectional I/O.
- A link can be established between any input and output streams to give them flush-on-access behavior. In
  other words, when data is requested from an input stream, its linked output stream will automatically flush.
  This behavior is available to all streams, but is particularly useful for file streams that may be dependent
  upon each other. Stream linking is accomplished with the ~tie()~ method. To tie an output stream to an input
  stream, call ~tie()~ on the input stream, and pass the address of the output stream. To break the link, pass
  ~nullptr~. One example of this stream linking is the link between ~cout~ and ~cin~. Whenever you try to
  input data from ~cin~, ~cout~ is automatically flushed.
- A bidirectional stream operates as both an input stream and an output stream. Bidirectional streams are
  deriving from ~iostream~, which in turn derives from both ~istream~ and ~ostream~, thus serving as an
  example of useful multiple inheritance. As you would expect, bidirectional streams support both the ~>>~
  operator and the ~<<~ operator, as well as the methods of both input streams and output streams.
- Bidirectional streams have separate pointers for the read position and the write position. When switching
  between reading and writing, you will need to ~seek~ to the appropriate position.

**** Warnings
- Note that graphical user interface applications normally do not have a console; i.e., if you write something
  to ~cout~, the user will not see it. If you are writing a library, you should never assume the existence of
  ~cout~, ~cin~, ~cerr~ or, ~clog~ because you never know if your library will be used in a console or in a
  GUI application.

*** Chapter 13 - Handling Errors
**** Notes
- Inevitably, your C++ programs will encounter errors. The program might be unable to open a file, the network
  connection might go down, or the user might enter an incorrect value, to name a few possibilities. The C++
  language provides a feature called exceptions to handle these exceptional but not unexpected situations.
- I recommend exceptions as a useful mechanism for error handling. I feel that the structure and
  error-handling formalization that exceptions provide outweigh the less desirable aspects. Also, many popular
  libraries, such as the =STL= and =Boost= use exceptions, so you need to be prepared to handle them.
- Although by default, streams do not throw exceptions, you can tell the streams to throw exceptions for error
  conditions by calling their ~exceptions()~ method. However, not all compilers give useful information in the
  stream exceptions they throw. For those compilers it might be better to deal with the stream state directly
  instead of using exceptions. This book does not use stream exceptions.
- It is recommended to catch exceptions by ~const reference~. This avoids object slicing which could happend
  when you catch exceptions by value.
- It is also possible to change the behavior of your program if there is an uncaught exception. When the
  program encounters an uncaught exception, it calls the built-in ~terminate()~ function, which calls
  ~abort()~ from ~<cstdlib>~ to kill the program. You can set your own ~terminate_handler~ by calling
  ~set_terminate()~ with a pointer to a callback function that takes no arguments and returns no value.
  ~terminate()~, ~set_terminate()~, and ~terminate_handler~ are all declared in the ~<exception>~ header.
- A function without a throw list can throw exceptions of any type. A function with ~noexcept~ shouldn't throw
  any exception.
- Since C++11, any exception specification is deprecated, except for ~noexcept~.
- Throw lists don't prevent functions from throwing unlisted exception types, but they prevent the exception
  from leaving the function, resulting a run-time error.
- When a function marked as ~noexcept~ throws an exception, C++ calls ~terminate()~ to terminate the
  application. When a function throws an exception that is not listed in its throw list, C++ calls a special
  function ~unexpected()~. The built-in implementation of ~unexpected()~ calls ~terminate()~.
- Never use throw lists because they are now deprecated, except for ~noexcept~. Instead, document the possible
  exceptions a function can throw in its code documentation.
- If you write a class whose objects will be thrown as exceptions, you must make those objects copyable. This
  means that if you have dynamically allocated memory, you must write a destructor, copy constructor, and
  assignment operator.
- Catch exception objects by reference to avoid unnecessary copying.
- It could happen that during handling of a first exception, a second exceptional situation is triggered which
  requires a second exception to be thrown. Unfortunately, when you throw the second exception, all
  information about the first exception that you are currently trying to handle will be lost. The solution
  provided by C++ for this problem is called nested exceptions, which allow you to nest a caught exception in
  the context of a new exception. You use ~std::throw_with_nested()~ to throw an exception with another
  exception nested inside it. A catch handler for the second exception can use a ~dynamic_cast~ to get access
  to the ~nested_exception~ representing the first exception.
- With smart pointers, you never have to remember to free the underlying resource: the smart pointer
  destructor does it for you, whether you leave the function via an exception or leave the function normally.
- C++ guarantees that it will run the destructor for any fully constructed "sub-objects". Therefore, any
  constructor that completes without an exception will cause the corresponding destructor to be run.

**** Warnings
- Catch and handle all possible exceptions thrown in your program.
- When you catch exceptions polymorphically, make sure to catch them by reference. If you catch exceptions by
  value, you can encounter slicing, in which case you lose information from the object.
- Objects thrown as exceptions are always copied by value at least once.
- Careless exception handling can lead to memory and resource leaks (because of stack unwinding).
- Remember, if and exception leaves a constructor, the destructor for that object will never be called!
- Be careful to catch in a destructor any exceptions that can be thrown by calls you make from the destructor.
  Never allow an exception to leave a destructor.

*** Chapter 14 - Overloading C++ Operators
**** Notes
- The ~operator[]~ can be used to both set and get elements because it returns a reference to the element.
  This reference can be used to assign to that element. When ~operator[]~ is used on the left-hand side of an
  assignment statement, the assignment actually changes the value at the given location.
- Although it's sometimes convenient for ~operator[]~ to return an element that can serve as an ~lvalue~, you
  don't always want that behavior. It would be nice to be able to provide read-only access to the elements of
  the array as well, by returning a ~const~ value or ~const~ reference. C++ provides a way to do this: if you
  mark the second ~operator[]~ with the attribute ~const~, then the compiler can distinguish between the two.
  If you call ~operator[]~ on a ~const~ object, it will use the const ~operator[]~, and, if you call it on a
  non-const object, it will use the non-const ~operator[]~.
- You cannot overload the subscripting operator to take more than one parameter. If you want to provide
  subscripting on more than one index, you can use the function call operator.
- You can overload the dereferencing operators for your classes in order to make objects of the classes behave
  like pointers. The main use of this capability is for implementing smart pointers. It is also useful for
  iterators, which the STL uses.
- Many programmers prefer ~operator void*()~ instead of ~operator bool()~.
- C++ gives you the ability to redefine the way memory allocation and deallocation work in your programs. You
  can provide this customization both on the global level and the class level. This capability is most useful
  when you are worried about memory fragmentation, which can occur if you allocate and deallocate a lot of
  small objects. For example, instead of going to the default C++ memory allocation each time you need memory,
  you could write a memory pool allocator that reuses fixed-size chunks of memory.
- You can overload ~operator new~ and ~operator delete~ to control memory allocation and deallocation, but you
  cannot overload the =new-expression= or the =delete-expression=. Thus, you can customize the actual memory
  allocation and deallocation, but not the calls to the constructor and destructor.

**** Warnings
- You should rarely, if ever, write an implementation of just one of ~operator*~ and ~operator->~. You should
  almost always write both operators together. It would confuse the users of your class if you failed to
  provide both.
- Unless you know a lot about memory allocation strategies, attempts to overload the memory allocation
  routines are rarely worth the trouble. Don't overload them just because it sounds like a neat idea. Only do
  so if you have a genuine requirement and the necessary knowledge.
- If you fail to heed my advice and decide to replace the global ~operator new~, keep in mind that you cannot
  put any code in the operator that makes a call to ~new~ because this will cause an infinite loop. For
  example, you cannot write a message to the console with ~cout~. A more useful technique is to overload
  ~operator new~ and ~operator delete~ for specific classes. These overloaded operators will be called only
  when you allocate and deallocate objects of that particular class.
- Whenever you overload ~operator new~, overload the corresponding form of ~operator delete~. Otherwise,
  memory will be allocated as you specify but freed according to the built-in semantics, which may not be
  compatible.
- Overload all forms of ~operator new~, or explicitly delete forms that you don't want to get used.
- If your class declares two identical versions of ~operator delete~ except that one takes the size parameter
  and the other doesn't, the version without the size parameter will always get called. If you want the
  version with the size parameter to be used, write only that version.

*** Chapter 15 - Overview of the C++ Standard Library
**** Notes

**** Warnings

*** Chapter 16 - Understanding Containers and Iterators
**** Notes
**** Warnings
*** Chapter 17 - Mastering STL Algorithms
**** Notes
**** Warnings
*** Chapter 18 - String Localization and Regular Expressions
**** Notes
**** Warnings
*** Chapter 19 - Additional Library Utilities
**** Notes
**** Warnings
** Part IV - Mastering Advanced Features of C++
*** Chapter 20 - Customizing and Extending the STL
**** Notes
**** Warnings
*** Chapter 21 - Advanced Templates
**** Notes
**** Warnings
*** Chapter 22 - Memory Management
**** Notes
**** Warnings
*** Chapter 23 - Multithreaded Programming with C++
**** Notes
**** Warnings
** Part V - C++ Software Engineering
*** Chapter 24 - Maximizing Software Engineering Methods
**** Notes
**** Warnings
*** Chapter 25 - Writing Efficient C++
**** Notes
**** Warnings
*** Chapter 26 - Conquering Debugging
**** Notes
**** Warnings
** Appendix A - C++ Interviews
** Appendix B - Annotated Bibliography
** Appendix C - Standard Library Header Files

** Stuff
*** References
A ~reference~ in C++ is an alias for another variable. All modifications to the reference change the value of
the variable to which it refers. You can think of references as implicit pointers that save you the trouble of
taking the address of variables and de-referencing the pointer. Alternatively, you can think of references as
just another name for the original variable. You can create stand-alone reference variables, use reference
data members in classes, accept references as parameters to functions and methods, and return references from
functions and methods.

**** Reference Variables
Reference variables must be initialized as soon as they are created, like this:
#+BEGIN_SRC c++
  int x = 3;
  int& xRef = x;
  int& emptyRef; // Does Not Compile!
#+END_SRC

***** Modifying References
A reference always refer to the same variable to which it is initialized; references cannot be changed once
they are created.
#+BEGIN_SRC c++
  int x = 3, y = 4;
  int& xRef = x;
  xRef = y; // Changes value of x to 4. Doesn't make xRef refer to y.

  int x = 3, z = 5;
  int& xRef = x;
  int& zRef = z;
  zRef = xRef; // Assigns values, not references (set the value of z to 3, doesn't change zRef)
#+END_SRC

***** References to Pointers and Pointers to References
You can create references to any type, including pointer types. You cannot declare a reference to a reference,
or a pointer to a reference.
#+BEGIN_SRC c++
  int* intP;            // intP is a pointer to int
  int*& ptrRef = intP;  // ptrRef is a reference to intP
  ptrRef = new int;
  *ptrRef = 5;
#+END_SRC

**** Reference Data Members
Data members of classes can be references. A reference cannot exist without referring to some other variable.
Thus, you must initialize reference data members in the constructor initializer, not in the body of the
constructor.
#+BEGIN_SRC c++
  class MyClass {
  public:
    MyClass(int& ref) : mRef(ref) {}

  private:
    int& mRef;
  };
#+END_SRC

**** Reference Parameters
C++ programmers do not often use stand-alone reference variables or reference data members. The most common
use of references is for parameters to functions and methods. Recall that the default parameter-passing
semantics are pass-by-value: Functions receive copies of their arguments. When those parameters are modified,
the original arguments remain unchanged. References allow you to specify pass-by-reference semantics for
arguments passed to the function. When you use reference parameters, the function receives references to the
function arguments. If those references are modified, the changes are reflected in the original argument
variables.
#+BEGIN_SRC c++
  void swap(int& first, int& second) {
    int temp = first;
    first = second;
    second = temp;
  }

  int x = 5, y = 6;
  int *xp = &x, *yp = &y;

  swap(x, y);    // x and y are actually changed through references in swap
  swap(*xp, *yp) // x and y are actually changed through references in swap
  swap(3, 4);    // Does not Compile!
#+END_SRC

**** Reference Return Values
You can also return a reference from a function or method. The main reason to do so is efficiency. Instead of
returning a whole object, return a reference to the object to avoid copying it unnecessarily. Of course, you
can only use this technique if the object in question will continue to exist following the function
termination.

If the type you want to return from your function supports move semantics, discussed later in this chapter,
then returning it by value is almost as efficient as returning a reference.

A second reason to return a reference is if you want to be able to assign to the return value directly as an
=lvalue= (the left-hand side of an assignment statement). Several overloaded operators commonly return
references.

**** Rvalue References
In C++, an ~lvalue~ is something of which you can take an address; a named variable, for example. The name
comes from the fact that they normally appear on the left-hand side of an assignment. An ~rvalue~ on the other
hand is anything that is not an ~lvalue~ such as a constant value, or a temporary object or value. Typically
an ~rvalue~ is on the right-hand side of an assignment operator.

An ~rvalue reference~ is a reference to an ~rvalue~. In particular, it is a concept that is applied when the
~rvalue~ is a temporary object. The purpose of an ~rvalue reference~ is to make it possible for a particular
function to be chosen when a temporary object is involved. The consequence of this is that certain operations
that normally involve copying large values can be implemented by copying pointers to those values, knowing the
temporary object will be destroyed.

A function can specify an ~rvalue reference~ parameter by using ~&&~ as part of the parameter specification;
e.g., ~type&& name~. Normally, a temporary object will be seen as a ~const type&~, but when there is a
function overload that uses an ~rvalue reference~, a temporary object can be resolved to that overload.

*** The ~const~ keyword
The keyword ~const~ is short for "constant" and specifies that something remains unchanged. The compiler will
enforce this requirement by marking any attempt to change it as an error. Furthermore, when optimizations are
enabled, the compiler can take advantage of this knowledge to produce better code. The keyword has two related
roles. It can mark variables or parameters, and it can mark methods.

**** ~const~ Variables and Parameters
You can use ~const~ to "protect" variables by specifying that they cannot be modified. You can mark any
variable ~const~, including global variables and class data members. Defining a constant with ~const~ is just
like defining a variable, except that the compiler guarantees that code cannot change the value.
#+BEGIN_SRC c++
  const double PI = 3.141592653589793238462;
  const std::string productName = "Super Hyper Net Modulator";
#+END_SRC

You can also use ~const~ to specify that parameters to functions or methods should remain unchanged.
#+BEGIN_SRC c++
  void mysteryFunction(const std::string* someString) {
    *someString = "Test"; // Will not compile
  }
#+END_SRC

***** ~const~ Pointers
#+BEGIN_SRC c++
  const int* ip; // Same as int const* ip;
  ip = new int[10];
  ip[4] = 5; // DOES NOT COMPILE! (Cannot change the value to wich ip points)

  int* const ip = nullptr; // mark ip itself const (not the values to which it points)
  ip = new int[10];        // DOES NOT COMPILE!
  ip[4] = 5;               // Error: dereferencing a null pointer

  int* const ip = new int[10]; // OK
  ip[4] = 5;                   // OK
  ip = new int[20];            // DOES NOT COMPILE!

  const int* const ip = nullptr; // both the pointer and the values to which it points are const
#+END_SRC

***** ~const~ References
~const~ applied to references is usually simpler than ~const~ applied to pointers for two reasons. First,
references are ~const~ by default, in that you can't change to what they refer. So, there is no need to mark
them ~const~ explicitly. Second, you can't create a reference to a reference, so there is usually only one
level of indirection with references. The only way to get multiple levels of indirection is to create a
reference to a pointer.
#+BEGIN_SRC c++
  int z;
  int const& zRef = z; // Same as: const int& zRef = z;
  zRef = 4; // DOES NOT COMPILE!
#+END_SRC

By passing a ~const~ reference you ensure that no copy is made but the original variable cannot be changed.
#+BEGIN_SRC c++
  void printString(const std::string& someString) {
    std::cout << someString << std::endl;
  }
#+END_SRC

**** ~const~ Methods
You can mark a class method ~const~, which prevents the method from modifying any non-mutable data members of
the class.

**** The ~constexpr~ Keyword
Constant expressions are evaluated at compile time.
#+BEGIN_SRC c++
  const int getArraySize() { return 32; }
  int main() {
    int myArray[getArraySize()]; // Invalid in C++
    return 0;
  }

  constexpr int getArraySize() { return 32; }
  int main() {
    int myArray[getArraySize()]; // OK
    int mySecondArray[getArraySize() + 5]; // OK
    return 0;
  }
#+END_SRC

Declaring a function as ~constexpr~ imposes quite a lot of restrictions on what the function can do because
the compiler has to be able to evaluate the function at compile time, and the function is not allowed to have
any side effects. Here are a couple of restrictions:
- The function body shall be a single return statement that does not contain a ~goto~ statement or a try catch
  block, and does not throw any exceptions. It is allowed to call other ~constexpr~ functions.
- The return type of the function shall be a literal type. It cannot be ~void~.
- If the ~constexpr~ function is a member of a class, the function cannot be ~virtual~.
- All the function arguments shall be literal types.
- A ~constexpr~ function cannot be called until it's defined in the translation unit because the compiler
  needs to know the complete definition.
- ~dynamic_cast~ is not allowed.
- ~new~ and ~delete~ are not allowed.

By defining a ~constexpr~ constructor you can create constant expression variables of user-defined types. A
~constexpr~ constructor should satisfy the following requirements:
- All the constructor arguments should be literal types.
- The constructor body cannot be a function-try-block.
- The constructor body should satisfy the same requirements as the body of a ~constexpr~ function.
- All data members should be initialized with constant expressions.
#+BEGIN_SRC c++
  class Rect {
  public:
    constexpr Rect(int width, int height) : mWidth(width), mHeight(height) {}
    constexpr int getArea() const { return mWidth * mHeight; }
  private:
    int mWidth, mHeight;
  };

  int main() {
    constexpr Rect r(8, 2);
    int myArray[r.getArea()]; // OK
    return 0;
  }
#+END_SRC

*** The ~static~ keyword
There are several uses of the keyword ~static~ in C++, all seemingly unrelated. Part of the motivation for
"overloading" the keyword was attempting to avoid having to introduce new keywords into the language.

**** ~static~ Data Members and Methods
You can declare ~static~ data members and methods of classes. ~static~ data members, unlike non-static data
members, are not part of each object. Instead, there is only one copy of the data member, which exists outside
any objects of that class.

~static~ methods are similarly at the class level instead of the object level. A ~static~ method does not
execute in the context of a specific object.

**** ~static~ Linkage
C++ source files are each compiled independently, and the resulting object files are linked together. Each
name in a C++ source file, including functions and global variables, has a linkage that is either ~internal~
or ~external~. External linkage means that the name is available from other source files. Internal linkage
(also called ~static linkage~) means that it is not. By default, functions and global variables have external
linkage. However, you can specify internal (or static) linkage by prefixing the declaration with the keyword
~static~.

An alternative to using ~static~ for internal linkage is to employ ~anonymous namespaces~. Instead of marking
a variable or function ~static~, wrap it in an unnamed ~namespace~. Entities in an ~anonymous namespace~ can
be accessed anywhere following their declaration in the same source file, but cannot be accessed from other
source files. These semantics are the same as those obtained with the ~static~ keyword.

**** The ~extern~ Keyword
A related keyword, ~extern~, seems like it should be the opposite of ~static~, specifying external linkage for
the names it precedes. It can be used that way in certain cases. For example, ~consts~ and ~typedefs~ have
internal linkage by default. You can use ~extern~ to give them external linkage. However, ~extern~ has some
complications. When you specify a name as ~extern~, the compiler treats it as a declaration, not a definition.
For variables, this means the compiler doesn't allocate space for the variable. You must provide a separate
definition line for the variable without the ~extern~ keyword.

**** ~static~ Variables in Functions
The final use of the ~static~ keyword in C++ is to create local variables that retain their values between
exits and entrances to their scope. A ~static~ variable inside a function is like a global variable that is
only accessible from that function. One common use of ~static~ variables is to "remember" whether a particular
initialization has been performed for a certain function.

*** Types
**** ~typedef~
A ~typedef~ provides a new name for an existing type declaration. You can think of a ~typedef~ as syntax for
introducing a synonym for an existing type declaration without creating a new type.
#+BEGIN_SRC c++
  typedef int* IntPtr;
  int* p1;   // p1 is a pointer to int
  IntPtr p2; // p2 is also a pointer to int
  p1 = p2;   // they are the same type (compatible)
  p2 = p1;   // they are the same type (compatible)

  typedef std::vector<std::string> StringVector;
  void processVector(const StringVector& vec) { /* omitted */ }
  int main() {
    StringVector myVector;
    processVector(myVector);
    return 0;
  }
#+END_SRC

The STL uses ~typedefs~ extensively to provide shorter names for types. For example, ~string~ is actually a
~typedef~ that looks like this: ~typedef basic_string<char, char_traits<char>, allocator<char>> string;~

**** Type Aliases
Type aliases are easier to understand than ~typedefs~ in certain situations.
#+BEGIN_SRC c++
  typedef int MyInt;
  using MyInt = int; // same as above

  typedef int (*FuncType)(char, double);
  using FuncType = int (*)(char, double); // same as above
#+END_SRC

**** Alias Templates
You can use a ~typedef~ to give another name to a templatized class. However, C++ requires you to specify
concrete arguments for each template parameter. Use alias template to be able to specify some of the types
only.
#+BEGIN_SRC
  template<typename T1, typename T2>
  class MyTemplateClass {/* ... */};

  typedef MyTemplateClass<int, double> OtherName; // Wors as expected

  template<typenamt T1>
  typedef MyTemplateClass<T1, double> OtherName; // Error

  template<typename T1>
  using OtherName = MyTemplateClass<T1, double>; // Using alias template works!
#+END_SRC

*** Casts
**** ~const_cast~
You can use ~const_cast~ to cast away const-ness of a variable.
#+BEGIN_SRC c++
  extern void ThirdPartyLibraryMethod(char* str);
  void f(const char* str) {
    ThirdPartyLibraryMethod(const_cast<char*>(str));
  }
#+END_SRC

**** ~static_cast~
You can use the ~static_cast~ to perform explicit conversions that are supported directly by the language.
#+BEGIN_SRC c++
  int i = 3, j = 4;
  double result = static_cast<double>(i) / j;
#+END_SRC

You can also use ~static_cast~ to perform explicit conversions that are allowed because of user-defined
constructors or conversions routines. For example, if class A has a constructor that takes an object of
class B, you can convert a B object to an A object with a ~static_cast~. In most situations where you want
this behavior, however, the compiler will perform the conversion automatically.

Another use for ~static_cast~ is to perform downcasts in an inheritance hierarchy. This casts work with both
pointers and references, they do not work with objects themselves. Note that these casts with ~static_cast~ do
not perform run-time type checking. They allow you to convert any Base pointer to a Derived pointer or Base
reference to a Derived reference, even if the Base really isn't a Derived at run time.
#+BEGIN_SRC c++
  class Base {
  public:
    Base() {}
    virtual ~Base() {}
  };

  class Derived : public Base {
  public:
    Derived() {}
    virtual ~Derived() {}
  };

  Base* b;
  Derived* d = new Derived();
  b = d;                        // Don't need a cast to go up the inheritance hierarchy
  d = static_cast<Derived*>(b); // Need a cast to go down the hierarchy

  Base base;
  Derived derived;
  Base& br = derived;
  Derived& dr = static_cast<Derived&>(br);
#+END_SRC

~static_casts~ are not all-powerful. You can't ~static_cast~ pointers of one type to pointers of another
unrelated type. You can't ~static_cast~ directly objects of one type to objects of another type. You can't
~static_cast~ a ~const~ type to a ~non-const~ type. You can't ~static_cast~ pointers to ~ints~. Basically, you
can't do anything that doesn't make sense according to the type rules of C++.

**** ~reinterpret_cast~
The ~reinterpret_cast~ is a bit more powerful and less safe than the ~static_cast~. You can use it to perform
some casts that are not technically allowed by C++ type rules, but which might make sense to the programmer in
some circumstances. For example, you can cast a reference to one type to a reference to another type, even if
the types are unrelated. Similarly, you can cast a pointer type to any other pointer type, even if they are
unrelated by an inheritance hierarchy. This is commonly used to cast a pointer to a ~void*~ and back. A
~void*~ pointer is just a pointer to some location in memory. No type information is associated with a ~void*~
pointer. You should be very careful with ~reinterpret_cast~ because it allows you to do conversions without
performing any type checking.
#+BEGIN_SRC c++
  class X {};
  class Y {};

  X x;
  Y y;
  X* xp = &x;
  Y* yp = &y;
  // Need reinterpret cast for pointer conversion from unrelated classes
  // static_cast doesn't work
  xp = reinterpret_cast<X*>(yp);
  // No cast required for conversion from pointer to void*
  void* p = xp;
  // Need reinterpret cast for pointer conversion from void*
  xp = reinterpret_cast<X*>(p);
  // Need reinterpret cast for reference conversion from unrelated classes
  // static_cast doesn't work
  X& xr = x;
  Y& yr = reinterpret_cast<Y&>(x);
#+END_SRC

**** ~dynamic_cast~
The ~dynamic_cast~ provides a run-time check on casts within an inheritance hierarchy. You can use it to cast
pointers or references. ~dynamic_cast~ checks the run-time type information of the underlying object at run
time. If the cast doesn't make sense, ~dynamic_cast~ returns a null pointer (for the pointer version) or
throws an ~std::bad_cast~ exception (for the reference version). Note that the run-time type information is
stored in the vtable of the object. Therefore, in order to use ~dynamic_cast~, your classes must have at least
one virtual method. If your classes don't have a vtable, trying to use ~dynamic_cast~ will result in a
compiler error.
#+BEGIN_SRC c++
  class Base {
  public:
    Base() {}
    virtual ~Base() {}
  };

  class Derived : public Base {
  public:
    Derived() {}
    virtual ~Derived() {}
  };

  // correct use of dynamic_cast
  Base* b;
  Derived* d = new Derived();
  b = d;
  d = dynamic_cast<Derived*>(b);

  // dynamic cast on references casue an exception to be thrown
  Base base;
  Derived derived;
  Base& br = base;
  try {
    Derived& dr = dynamic_cast<Derived&>(br);
  } catch (const std::bad_cast&) {
    cout << "Bad cast!\n";
  }
#+END_SRC

Note that you can perform the same casts down the inheritance hierarchy with a ~static_cast~ or
~reinterpret_cast~. The difference with ~dynamic_cast~ is that it performs run-time (dynamic) type checking,
while ~static_cast~ and ~reinterpret_cast~ will perform the casting even if they are erroneous.

**** Casting Up and Down
An object can be cast or assigned to its parent class. If the cast or assignment is performed on a plain old
object, this results in slicing. However, slicing does not occur if a derived class is assigned to a pointer
or reference to its base class.
#+BEGIN_SRC c++
  Super mySuper = mySub;  // Slice!
  Super& mySuper = mySub; // No Slice!
#+END_SRC

Casting from a base class to one of its derived classes, also called downcasting, is often frowned upon by
professional C++ programmers because there is no guarantee that the object really belongs to that derived
class, and because downcasting is a sign of bad design.
#+BEGIN_SRC c++
  void presumptuous(Super* inSuper) {
    Sub* mySub = static_cast<Sub*>(inSuper); // BAD!!!
    // Proceed to access Sub methods on mySub.
  }

  void lessPresumptuous(Super* inSuper) {
    Sub* mySub = dynamic_cast<Sub*>(inSuper);
    if (mySub != nullptr) {
      // Proceed to access Sub methods on mySub.
    }
  }
#+END_SRC

**** Summary of Casts
| Situation                                                              | Cast                         |
|------------------------------------------------------------------------+------------------------------|
| Remove const-ness                                                      | const_cast                   |
|------------------------------------------------------------------------+------------------------------|
| Explicit cast supported by language (e.g., int to double, int to bool) | static_cast                  |
|------------------------------------------------------------------------+------------------------------|
| Explicit cast supported by user-defined constructors or conversions    | static_cast                  |
|------------------------------------------------------------------------+------------------------------|
| Object of one class to object of another (unrelated) class             | Can't be done                |
|------------------------------------------------------------------------+------------------------------|
| Pointer-to-object of one class to pointer-to-object of another class   | dynamic_cast recommended, or |
| in the same inheritance hierarchy                                      | static_cast                  |
|------------------------------------------------------------------------+------------------------------|
| Reference-to-object of one class to reference-to-object of another     | dynamic_cast recommended, or |
| class in the same inheritance hierarchy                                | static_cast                  |
|------------------------------------------------------------------------+------------------------------|
| Pointer-to-type to unrelated pointer-to-type                           | reinterpret_cast             |
|------------------------------------------------------------------------+------------------------------|
| Reference-to-type to unrelated reference-to-type                       | reinterpret_cast             |
|------------------------------------------------------------------------+------------------------------|
| Pointer-to-function to pointer-to-function                             | reinterpret_cast             |
|------------------------------------------------------------------------+------------------------------|

*** Type Inference
Type inference allows the compiler to automatically deduce the type of an expression. There are two keywords
for type inference: =auto= and =decltype= and C++14 add =decltype(auto)=.

**** The =auto= keyword
The =auto= keyword has four completely different meanings:
1. The first meaning is to tell the compiler to automatically deduce the type of a variable at compile time.
2. The second use of the =auto= keyword is for the =alternative function syntax=.
3. The third use of the =auto= keyword is for =function return type deduction=
4. The fourth use of =auto= is for generic lambda expressions.

**** The =decltype= keyword
The =decltype= keyword takes an expression as argument, and computes the type of that expression. For example:
#+BEGIN_SRC C++
  int x = 123;
  decltype(x) y = 456; // The compiler deduces the type of y to be int because that's the type of x
#+END_SRC

**** =decltype(auto)=
Using =auto= to deduce the type of an expression strips away reference qualifiers and const qualifiers.
=decltype= does not strip those, but might cause code duplication. C++14 solves this by introducing
=decltype(auto)=.
#+BEGIN_SRC c++
  const string message = "Test";
  const string& foo() { return message; }

  auto f1 = foo();            // f1 is of type string and thus a copy is made.
  const auto& f1 = foo();     // explicitely make it a reference and mark it const.
  decltype(foo()) f1 = foo(); // f1 is of type const string& but the syntax is ugly.
  decltype(auto) f1 = foo();  // f1 is of type const string&.
#+END_SRC

*** Smart Pointers
To avoid common memory problems, you should use smart pointers instead of normal "naked" C-style pointers.
Smart pointers automatically deallocate memory when the smart pointer object goes out of scope, for example
when the function has finished executing.

The difference between =shared_ptr= and =unique_ptr= is that =shared_ptr= is a reference-counted smart
pointer, while =unique_ptr= is not reference counted. This means that you can have several =shared_ptr=
instances pointing to the same dynamically allocated memory and the memory will only be deallocated when the
last =shared_ptr= goes out of scope. =shared_ptr= is also thread-safe.

=unique_ptr= on the other hand means ownership. When the single =unique_ptr= goes out of scope, the underlying
memory is freed. Your default smart pointer should be =unique_ptr=. Use only =shared_ptr= when you need to
share the resource.

**** std::unique_ptr
The =unique_ptr= is analogous to an ordinary pointer, except that it will automatically free the memory or
resource when the =unique_ptr= goes out of scope or is deleted. A =unique_ptr= has sole ownership of the
object pointed to.

=unique_ptr= does not support the normal copy assignment operator and copy constructor, but it does support
the move assignment operator and move constructor, which explains why you can return a =unique_ptr= from a
function.

#+BEGIN_SRC C++
  Employee *emp = new Employee;               // normal "naked" pointer
  auto emp = std::make_unique<Employee>();    // std::unique_ptr smart pointer (C++14)
  std::unique_ptr<Employee> emp(new Employee) // std::unique_ptr smart pointer (C++11)

  auto p1 = std::make_unique<int>(42);
  std::unique_ptr<int> p2 = p1;              // Error: does not compile. No copy constructor.
  std::unique_ptr<int> p3 = std::move(p1);   // OK. Ownership has been moved from p1 to p3.
#+END_SRC

**** std::shared_ptr
=shared_ptr= allows for distributed "ownership" of data. Each time a =shared_ptr= is assigned, a reference
count is incremented indicating there is one more "owner" of the data. When a =shared_ptr= goes out of scope,
the reference count is decremented. When the reference count goes to zero it means there is no longer any
owner of the data, and the object referenced by the pointer is freed. You can't store an array in a
=shared_ptr=.

=const_pointer_cast()=, =dynamic_pointer_cast()=, and =static_pointer_cast()= are functions available to cast
=shared_ptrs=.

#+BEGIN_SRC c++
  auto emp = std::make_shared<Employee>();    // std::shared_ptr smart pointer (C++14)
  std::shared_ptr<Employee> emp(new Employee) // std::shared_ptr smart pointer (C++11)

  std::shared_ptr<Base> myBasePtr(new Derived);
  std::shared_ptr<Derived> myDerivedPtr = std::dynamic_pointer_cast<Derived>(myBasePtr);
#+END_SRC

**** std::weak_ptr
You can use a =weak_ptr= to observe a =shared_ptr= without incrementing or decrementing the reference count of
the linked =shared_ptr=.

A =weak_ptr= can contain a reference to memory managed by a =shared_ptr=. The =weak_ptr= does not own the
memory, so the =shared_ptr= is not prevented from deallocating the memory. A =weak_ptr= does not destroy the
pointed to memory when it goes out of scope; however, it can be used to determine if the memory has been
deallocated by the associated =shared_ptr= or not. The constructor of a =weak_ptr= requires a =shared_ptr= or
another =weak_ptr= as argument. To get access to the pointer stored in a =weak_ptr= you need to convert it to
a =shared_ptr=. There are two ways to do this:
- Use the =lock()= method on a =weak_ptr= instance, which returns a =shared_ptr=.
- Create a new =shared_ptr= instance and give a =weak_ptr= as argument to the =shared_ptr= constructor.
In both cases, this new =shared_ptr= will be =nullptr= if the =shared_ptr= associated with the =weak_ptr= has
been deallocated in the meantime.

*** Access Specifiers
| Specifier | Meaning                                      | When to Use                                        |
|-----------+----------------------------------------------+----------------------------------------------------|
| public    | Any code can call public member function     | Behaviors (methods) that you want clients to use.  |
|           | or access a public data member of an object. | Access methods for private and protected data      |
|           |                                              | members.                                           |
|-----------+----------------------------------------------+----------------------------------------------------|
| protected | Any member function of the class can call    | "Helper" methods that you don not want clients     |
|           | protected member functions and access        | to use.                                            |
|           | protected data members. Member functions of  |                                                    |
|           | derived class can access protected members   |                                                    |
|           | of a base class.                             |                                                    |
|-----------+----------------------------------------------+----------------------------------------------------|
| private   | Only members functions of the class can call | Everything should be private by default,           |
|           | private member functions and access private  | especially data members. You can provide protected |
|           | data members. Member functions in derived    | getters and setters if you only want to allow      |
|           | classes cannot access private members from   | derived classes access them, and provide public    |
|           | a base class.                                | getters and setters if you want clients to access  |
|           |                                              | them.                                              |
|-----------+----------------------------------------------+----------------------------------------------------|

*** Constructors and Destructors
**** Summary of Compiler-Generated Constructors
The compiler automatically generates a 0-argument and copy constructor for every class. However, the
constructors you define yourself replace these according to the following rules:

| If you define...         | ...then the compiler generates... | ...and you can create an object...          |
|--------------------------+-----------------------------------+---------------------------------------------|
| [no constructors]        | A 0-argument constructor          | With no arguments:                          |
|                          | A copy constructor                | =SpreadsheetCell cell;=                     |
|                          |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell myCell(cell);=             |
|--------------------------+-----------------------------------+---------------------------------------------|
| A 0-argument             | A copy constructor                | With no arguments:                          |
| constructor only         |                                   | =SpreadsheetCell cell;=                     |
|                          |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell myCell(cell);=             |
|--------------------------+-----------------------------------+---------------------------------------------|
| A copy constructor       | No constructors                   | Theoretically, as a copy of another object. |
| only                     |                                   | Practically, you can't create any objects.  |
|--------------------------+-----------------------------------+---------------------------------------------|
| A single-argument or     | A copy constructor                | With arguments:                             |
| multi-argument non-      |                                   | =SpreadsheetCell cell(6);=                  |
| copy constructor only    |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell myCell(cell);=             |
|--------------------------+-----------------------------------+---------------------------------------------|
| A 0-argument constructor | A copy constructor                | With no arguments:                          |
| as well as a single-     |                                   | =SpreadsheetCell cell;=                     |
| argument or multi-       |                                   | With arguments:                             |
| argument non-copy        |                                   | =SpreadsheetCell myCell(5);=                |
| constructor              |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell anotherCell(cell);=        |
|--------------------------+-----------------------------------+---------------------------------------------|

Note the lack of symmetry between the default constructor and the copy constructor. As long as you don't
define a copy constructor explicitly, the compiler creates one for you. On the other hand, as soon as you
define any constructor, the compiler stops generating a default constructor. As mentioned before in this
chapter, the automatic generation of a default constructor and a default copy constructor can be influenced by
defining them as explicitly defaulted or explicitly deleted.

**** Constructor Order
Objects don't spring to live all at once; they must be constructed along with their parents and any objects
that are contained within them. C++ defines the creation order as follows:

1. If the class has a base class, the default constructor of the base class is executed, unless there is a
   call to a base class constructor in the ctor-initializer in which case that constructor is called instead
   of the default constructor.
2. Non-static data members of the class are constructed in the order in which they are declared.
3. The body of the class's constructor is executed.

These rules can apply recursively. If the class has a grandparent, the grandparent is initialized before the
parent, and so on.

**** Destructor Order
Because destructors cannot take arguments, the language can always automatically call the destructor for
parent classes. The order of destruction is conveniently the reverse of the order of construction:

1. The body of the class's destructor is called.
2. Any data members of the class are destroyed in the reverse order of their construction.
3. The parent class, if any, is destructed.

Again, these rules apply recursively. The lowest member of the chain is always destructed first.

*** Rule of Six
- Default Constructor
- Copy Constructor
- Move Constructor (C++11 or higher)
- Copy Assignment Operator
- Move Assignment Operator (C++11 or higher)
- Destructor (Should be virtual)

#+BEGIN_SRC c++
  Spreadsheet();                             // ctor
  Spreadsheet(const Spreadsheet& src);       // copy ctor
  Spreadsheet(Spreadsheet&& src) noexcept;   // move ctor
  virtual ~Spreadsheet();                    // destructor

  Spreadsheet& operator=(const Spreadsheet& rhs);      // assignment operator
  Spreadsheet& operator=(Spreadsheet&& rhs) noexcept;  // move assignment operator
#+END_SRC

C++ has six methods (four in C++03) with a default behavior. The code for those can be generated by the
compiler - saving us from boring routine work and thus preventing oversights. Regarding the six operations,
implement as little as possible and declare as much as possible. Any operation not implemented shall be
declared as =default= or =delete=.

Move semantics for objects requires a move constructor and a move assignment operator. These will be used by
the compiler on places where the source object is a temporary object that will be destroyed after the copy or
assignment. Both the move constructor and the move assignment operator copy/move the member variables from the
source object to the new object and then reset the variables of the source object to null values. By doing
this, they are actually moving ownership of the memory from one object to another object. They basically do a
shallow copy of the member variables and switch ownership of allocated memory to prevent dangling pointers or
memory leaks.

Move semantics is implemented by using =rvalue= references. To add move semantics to a class, a move
constructor and a move assignment operator need to be implemented. Move constructors and move assignment
operators should be marked with the ~noexcept~ qualifier to tell the compiler that they don't throw any
exceptions. This is particularly important for compatibility with the standard library, as fully compliant
implementations of the standard library will only move stored objects if, having move semantics implemented,
they also guarantee not to throw.

Obviously, move semantics is useful only when you know that the source object will be destroyed.

*** Inheritance
**** Copy Constructor and assignment operator on derived classes
Providing a copy constructor and assignment operator is considered a good programming practice when you have
dynamically allocated memory in the class. When defining a derived class, you need to be careful about copy
constructors and ~operator=~. If your derived class does not have any special data (pointers, usually) that
require a non-default copy constructor or ~operator=~, you don't need to have one, regardless of whether or
not the base class has one. If your derived class omits the copy constructor or ~operator=~, a default copy
constructor or ~operator=~ will be provided for the data members specified in the derived class and the base
class copy constructor or ~operator=~ will be used for the data members specified in the base class. On the
other hand, if you do specify a copy constructor in the derived class, you need to explicitly chain to the
parent copy constructor. If you do not do this, the default constructor (not the copy constructor!) will be
used for the parent portion of the object. Similarly, if the derived class overrides ~operator=~, it is almost
always necessary to call the parent's version of ~operator=~ as well.
#+BEGIN_SRC
class Super {
public:
  Super();
  Super(const Super& inSuper);
  Super& operator=(const Super& inSuper);
};

class Sub : public Super {
public:
  Sub();
  Sub(const Sub& inSub);
  Sub& operator=(const Sub& inSub);
};

Sub::Sub(const Sub& inSub) : Super(inSub) {}
Sub& Sub::operator=(const Sub& inSub) {
  if (&inSub == this) { return *this; }
  Super::operator=(inSub); // calls parent's operator=
  // Do necessary assignment for derived class
  return *this;
}
#+END_SRC

**** Multiple Inheritance
#+BEGIN_SRC c++
  class Baz : public Foo, public Bar {};
#+END_SRC

By listing multiple parents, the =Baz= object will have the following characteristics:
- A =Baz= object will support the =public= methods and contain the data members of both =Foo= and =Bar=.
- The methods of the =Baz= class will have access to =protected= data and methods in both =Foo= and =Bar=.
- A =Baz= object can be upcast to either a =Foo= or a =Bar=.
- Creating a new =Baz= object will automatically call the =Foo= and =Bar= default constructors, in the order
  that the classes are listed in the class definition.
- Deleting a =Bas= object will automatically call the destructors for the =Foo= and =Bar= classes, in the
  reverse order that the classes are listed in the class definition.

*** Using Interface and Implementation Classes (PIMPL Idiom)
Even with the preceding measures and the best design principles, the C++ language is fundamentally unfriendly
to the principle of abstraction. The syntax requires you to combine your public interfaces and private (or
protected) data members and methods together in one class definition, thereby exposing some of the internal
implementation details of the class to its clients. The downside of this is that if you have to add new
non-public methods or data members to your class, all the clients of the class have to be recompiled. This can
become a burden in bigger projects.

The good news is that you can make your interfaces a lot cleaner and hide all implementation details,
resulting in stable interfaces. The bad news is that it takes a bit of hacking. The basic principle is to
define two classes for every class you want to write: the interface class and the implementation class. The
implementation class is identical to the class you would have written if you were not taking this approach.
The interface class presents public methods identical to those of the implementation class, but it only has
one data member: a pointer to an implementation class object. This is called the =pimpl idiom=, or private
implementation idiom. The interface class method implementations simply call the equivalent methods on the
implementation class object. The result of this is that no matter how the implementation changes, it has no
impact on the public interface class. This reduces the need for recompilation. None of the clients that use
the interface class need to be recompiled if the implementation (and only the implementation) changes. Note
that this idiom only works if the single data member is a pointer to the implementation class. If it would be
a by-value data member, the clients would have to be recompiled when the definition of the implementation
class changes.

*** Generic Code with Templates
**** Inheritance versus Specialization
Some programmers find the distinction between template inheritance and template specialization confusing. The
following table summarizes the differences:
|               | Inheritance                           | Specialization                                     |
|---------------+---------------------------------------+----------------------------------------------------|
| Recuse Code?  | Yes: Derived classes contain all      | No: You must rewrite all required code in the      |
|               | base class data members and methods.  | specialization.                                    |
|---------------+---------------------------------------+----------------------------------------------------|
| Reuse name?   | No: The derived class name must be    | Yes: The specialization must have the same name as |
|               | different from the base class name.   | the original.                                      |
|---------------+---------------------------------------+----------------------------------------------------|
| Supports      | Yes: Objects of the derived class can | No: Each instantiation of a template for a type is |
| polymorphism? | stand in for objects of the base      | a different type.                                  |
|               | class.                                |                                                    |
|---------------+---------------------------------------+----------------------------------------------------|

*** IO Streams
All streams can be viewed as data chutes. Streams vary in their =direction= and their =associated source or
destination=. For example, the ~cout~ stream is an output stream, so its direction is "out." It writes data to
the console so its associated destination is "console." There is another standard stream called ~cin~ that
accepts input from the user. Its direction is "in," and its associated source is "console." Both ~cout~ and
~cin~ are predefined instances of streams that are defined within the ~std namespace~ in C++. The following
table gives a brief description of all predefined streams.
| Stream | Description                                                                          |
|--------+--------------------------------------------------------------------------------------|
| cin    | An input stream, reads data from the "input console."                                |
| cout   | A buffered output stream, writes data to the "output console."                       |
| cerr   | An un-buffered output stream, writes data to the "error console," which is often the |
|        | same as the "output console."                                                        |
| clog   | A buffered version of cerr.                                                          |
|--------+--------------------------------------------------------------------------------------|

**** Output Manipulators
One of the unusual features of streams is that you can throw more than just data down the chute. C++ streams
also recognize manipulators, objects that make a change to the behavior of the stream instead of, or in
addition to, providing data for the stream to work with. All the manipulators stay in effect for subsequent
output to the stream until they are reset, except ~setw~ which is only active for the next single output.
- ~boolalpha~ and ~noboolalpha~ :: Tells the stream to output ~bool~ values as =true= and =false=
     (~boolalpha~) or =1= and =0= (~noboolalpha~). The default is ~noboolalpha~.
- ~hex~, ~oct~ and ~dec~ :: Outputs numbers in hexadecimal, octal and base 10, respectively.
- ~setprecision~ :: Sets the number of decimal places that are output for fractional numbers. This is a
     parameterized manipulator (meaning that it takes an argument).
- ~setw~ :: Sets the field width for outputting numerical data. This is a parameterized manipulator.
- ~setfill~ :: Specifies the character that is used to pad numbers that are smaller than the specified width.
     This is a parameterized manipulator.
- ~showpoint~ and ~noshowpoint~ :: Forces the stream to always or never show the decimal point for floating
     point numbers with no fractional part.
- ~put_money~ :: Writes a formatted money amount to a stream.
- ~put_time~ :: Writes a formatted time to a stream.
- ~quoted~ :: A parameterized manipulator that encloses a given string with quotes and escapes embedded
     quotes.

**** Input Manipulators
The built-in input manipulators, described in the list that follows, can be sent to an input stream to
customize the way that data is read.
- ~boolalpha~ and ~noboolalpha~ :: If ~boolalpha~ is used, the string =false= will be interpreted as a Boolean
     value =false=; anything else will be treated as the Boolean value =true=. If ~noboolalpha~ is set, =0=
     will be interpreted as =false=, anything else as =true=. The default is ~noboolalpha~.
- ~hex~, ~oct~, and ~dec~ :: Reads numbers in hexadecimal, octal, and base 10, respectively.
- ~skipws~ and ~noskipws~ :: Tells the stream to either skip white space when tokenizing or to read in white
     space as its own token.
- ~ws~ :: A handy manipulator that simply skips over the current series of white space at the current position
     in the stream.
- ~get_money~ :: Reads a money amount from a stream.
- ~get_time~ :: Reads a formatted time from a stream.
- ~quoted~ :: A parameterized manipulator that reads a string enclosed with quotes and in which embedded
     quotes are escaped.

*** Exceptions
An exception is an unexpected situation. Exceptions come with some new terminology. When a piece of code
detects an exceptional situation, it =throws= an exception. Another piece of code =catches= the exception and
takes appropriate action. Exceptions can get tricky in C++. To use exceptions properly, you need to understand
what happens to the stack variables when an exception is thrown, and you have to be careful to properly catch
and handle the necessary exceptions. Unlike the Java language, the C++ compiler doesn't force you to catch
every exception that might occur. If your code never catches any exceptions but an exception is thrown, it
will be caught by the program itself, which will be terminated.

**** Memory Allocation Errors
The default behaviors of ~new~ and ~new[]~ are to throw an exception of type ~bad_alloc~, defined in the
~<new>~ header file, if they cannot allocate memory. Your code could catch these exceptions and handle them
appropriately. It's not realistic to wrap all your calls to ~new~ and ~new[]~ with a =try/catch=, but at least
you should do so when you are trying to allocate a big block of memory.

One consideration is that logging an error might try to allocate memory. If ~new~ fails, there might
not be enough memory left even to log the error message.

If you don't like exceptions, you can revert to the old C model in which memory allocation routines return a
~null~ pointer if they cannot allocate memory. C++ provides ~nothrow~ versions of ~new~ and ~new[]~, which
return ~nullptr~ instead of throwing an exception if they fail to allocate memory. This is done by using the
syntax ~new(nothrow)~ instead of ~new~.

**** Errors in Constructors
You can throw an exception from a constructor, even though you can't return a value. With exceptions you can
easily tell clients whether or not construction of the object succeeded. However, there is one major problem:
if an exception leaves a constructor, the destructor for that object will never be called. Thus, you must be
careful to clean up any resources and free any allocated memory in constructors before allowing exceptions to
leave the constructor. This problem is the same as in any other function, but it is subtler in constructors
because you're accustomed to letting the destructors take care of the memory deallocation and resource
freeing.

**** Errors in Destructors
You should handle all error conditions that arise in destructors in the destructors themselves. You should not
let any exceptions be thrown from destructors, for three reasons:
  1. Destructors can run while there is another pending exception, in the process of stack unwinding. If you
     throw an exception from the destructor in the middle of stack unwinding, the C++ runtime will call
     ~std::terminate()~ to terminate the application. For the brave and curious, C++ does provide the ability
     to determine, in a destructor, whether you are executing as a result of a normal function exit or delete
     call, or because of stack unwinding. The function ~uncaught_exception()~, declared in the ~<exception>~
     header file, returns true if there is an uncaught exception and you are in the middle of stack unwinding.
     Otherwise, it returns false. However, this approach is messy and should be avoided.
  2. What action would clients take? Clients don't call destructors explicitly: they call ~delete~, which
     calls the destructor. If you throw an exception from the destructor, what is a client supposed to do? It
     can't call delete on the object again, and it shouldn't call the destructor explicitly. There is no
     reasonable action the client can take, so there is no reason to burden that code with exception handling.
  3. The destructor is your one chance to free memory and resources used in the object. If you waste your
     chance by exiting the function early due to an exception, you will never be able to go back and free the
     memory or resources.

*** Operator Overloading
**** Limitations to Operator Overloading
- You cannot add new operator symbols. You can only redefine the meanings of operators already in the
  language.
- There are a few operators that you cannot overload, such as ~.~ (member access in an object), ~::~ (scope
  resolution operator, ~sizeof~, ~?:~ (the conditional operator), and a few others. The table below lists all
  the operators that you can overload. The operators that you can't overload are usually not those you would
  care to overload anyway, so you shouldn't find this restriction limiting.
- The =arity= describes the number of arguments, or operands, associated with the operator. You can only
  change the =arity= for the function call, ~new~ and ~delete~ operators. For all other operators you cannot
  change the =arity=. Unary operators, such as ~++~, work on only one operand. Binary operators, such as ~/~,
  work on two operands. There is only one ternary operator: ~?:~. The main place where this limitation might
  bother you is when overloading ~[]~ (array brackets).
- You cannot change the precedence or associativity of the operator. These rules determine in which order
  operators are evaluated in a statement. Again, this constraint shouldn't be cause for concern in most
  programs because there are rarely benefits to changing the order of evaluation.
- You cannot redefine operators for built-in types. The operator must be a method in a class, or at least one
  of the arguments to a global overloaded operator function must be a user-defined type (e.g., a class). This
  means that you can't do something ridiculous, such as redefine ~+~ for ~ints~ to mean subtraction (though
  you could do so for your classes). The one exception to this rule is the memory allocation and deallocation
  routines; you can replace the global routines for all memory allocations in your program.

**** Summary of Overloadable Operators
The following table lists the operators that you can overload, specifies whether they should be methods of the
class or global friend functions, summarizes when you should (or should not) overload them, and provides
sample prototypes showing the proper return values.

In this table, ~T~ is the name of the class for which the overloaded operator is written, and ~E~ is a
different type. Note that the sample prototypes given are not exhaustive; often there are other combinations
of ~T~ and ~E~ possible for a given operator.

| Operator    | Name or Category   | Friend Function | When to Overload      | Sample Prototype                 |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator+   | Binary             | Global friend   | Whenever you want     | friend T operator+(const T&,     |
| operator-   | arithmetic         | function        | to provide these      | const T&);                       |
| operator*   |                    | recommended     | operations for        | friend T operator+(const T&,     |
| operator/   |                    |                 | your class            | const E&);                       |
| operator%   |                    |                 |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator-   | Unary arithmetic   | Method          | Whenever you want     | T operator-() const;             |
| operator+   | and bitwise        | recommended     | to provide these      |                                  |
| operator~   | operators          |                 | operations for        |                                  |
|             |                    |                 | your class            |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator++  | Pre-increment and  | Method          | Whenever you          | T& operator++();                 |
| operator--  | pre-decrement      | recommended     | overload operator+=   |                                  |
|             |                    |                 | and operator-=        |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator++  | Post-increment and | Method          | Whenever you          | T operator++(int);               |
| operator--  | post-decrement     | recommended     | overload operator+=   |                                  |
|             |                    |                 | and operator-=        |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator=   | Assignment         | Method          | Whenever your class   | T& operator=(const T&);          |
|             | operator           | required        | has dynamically       |                                  |
|             |                    |                 | allocated memory or   |                                  |
|             |                    |                 | resources, or members |                                  |
|             |                    |                 | that are references   |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator+=  | Shorthand          | Method          | Whenever you overload | T& operator+=(const T&);         |
| operator-=  | arithmetic         | recommended     | the binary arithmetic | T& operator+=(const E&);         |
| operator*=  | operator           |                 | operators and your    |                                  |
| operator/=  | assignments        |                 | class is not designed |                                  |
| operator%=  |                    |                 | to be immutable       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator<<  | Binary bitwise     | Global friend   | Whenever you want to  | friend T operator<<(const T&,    |
| operator>>  | operators          | function        | provide these         | const T&);                       |
| operator&   |                    | recommended     | operations            | friend T operator<<(const T&,    |
| operator|   |                    |                 |                       | const E&);                       |
| operator^   |                    |                 |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator<<= | Shorthand bitwise  | Method          | Whenever you overload | T& operator<<=(const T&);        |
| operator>>= | operator           | recommended     | the binary bitwise    | T& operator<<=(const E&);        |
| operator&=  | assignments        |                 | operators and your    |                                  |
| operator|=  |                    |                 | class is not designed |                                  |
| operator^=  |                    |                 | to be immutable       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator<   | Binary comparison  | Global friend   | Whenever you want to  | friend bool operator<(const T&,  |
| operator>   | operators          | function        | provide these         | const T&);                       |
| operator<=  |                    | recommended     | operations            | friend bool operator<(const T&,  |
| operator>=  |                    |                 |                       | const E&);                       |
| operator==  |                    |                 |                       |                                  |
| operator!=  |                    |                 |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator<<  | I/O stream         | Global friend   | Whenever you want to  | friend ostream& operator<<(      |
| operator>>  | operators          | function        | provide these         | ostream&, const T&);             |
|             | (insertion and     | required        | operations            | friend istream& operator>>(      |
|             | extraction)        |                 |                       | istream&, T&);                   |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator!   | Boolean negation   | Member function | Rarely; use bool or   | bool operator!() const;          |
|             | operator           | recommended     | void* conversion      |                                  |
|             |                    |                 | instead               |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator&&  | Binary Boolean     | Global friend   | Rarely                | friend bool operator&&(          |
| operator||  | operators          | function        |                       | const T& lhs, const T& rhs);     |
|             |                    | recommended     |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator[]  | Subscripting       | Method          | When you want to      | E& operator[](int);              |
|             | (array index)      | required        | support               | const E& operator[](int) const;  |
|             | operator           |                 | subscripting          |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator()  | Function call      | Method          | When you want objects | Return type and arguments        |
|             | operator           | required        | to behave like        | can vary;                        |
|             |                    |                 | function pointers     |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator    | Conversion, or     | Method          | When you want to      | operator type() const;           |
| type()      | cast, operators    | required        | provide conversions   |                                  |
|             | (separate operator |                 | from your class       |                                  |
|             | for each type)     |                 | to other types        |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator    | Memory allocation  | Method          | When you want to      | void* operator new(size_t size); |
| new         | routines           | recommended     | control memory        | void* operator new[](            |
| operator    |                    |                 | allocation for your   | size_t size);                    |
| new[]       |                    |                 | classes (rarely)      |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator    | Memory             | Method          | Whenever you overload | void operator delete(void* ptr)  |
| delete      | deallocation       | recommended     | the memory allocation | noexcept;                        |
| operator    | routines           |                 | routines              | void operator delete[](          |
| delete[]    |                    |                 |                       | void * ptr) noexcept;            |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator*   | Dereferencing      | Method          | Useful for smart      | E& operator*() const;            |
| operator->  | operators          | recommended for | pointers              | E* operator->() const;           |
|             |                    | operator*       |                       |                                  |
|             |                    | Method required |                       |                                  |
|             |                    | for operator->  |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator&   | Address-of         | N/A             | Never                 | N/A                              |
|             | operator           |                 |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator->* | Dereference        | N/A             | Never                 | N/A                              |
|             | pointer-to-member  |                 |                       |                                  |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|
| operator,   | Comma operator     | N/A             | Never                 | N/A                              |
|-------------+--------------------+-----------------+-----------------------+----------------------------------|

The preceding table does not include sample prototypes with =rvalue= reference semantics. However, for most
operators it can make sense to write both a version using normal =lvalue= references and a version using
=rvalue= references. Whether it makes sense depends on implementation details of your class. The ~operator=~
is one example. Another example is ~operator+~ to prevent unnecessary memory allocations.

The logical operators are trickier. It's not recommended to overload ~&&~ and ~||~. These operators don't
really apply to individual types: they aggregate results of Boolean expressions. Additionally, you lose the
short-circuit evaluation, because both the left-hand side and the right-hand side have to be evaluated before
they can be bound to the parameters of your overloaded operator ~&&~ and ~||~. Thus, it rarely makes sense to
overload them for specific types.

*** Big-O Notation
=Big-O= notation specifies algorithm run time as a function of its input size, also known as the complexity of
the algorithm. For example, an algorithm with a performance that is linear as a function of its input size
takes twice as long to process twice as many elements. Thus, if it takes 2 seconds to process 500 elements, it
will take 4 seconds to process 1000 elements. That is, you could graph the performance versus input size as a
straight line. =Big-O= notation summarizes the algorithm performance like this: =O(n)=. The =O= just means
that you're using =big-O= notation, while the =n= represents the input size. =O(n)= specifies that the
algorithm speed is a direct linear function of the input size.

| Algorithm Complexity | Big-O Notation | Explanation                       | Example Algorithms                |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Constant             | O(1)           | Running time is independent of    | Accessing a single element in an  |
|                      |                | input size.                       | array.                            |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Logarithmic          | O(log n)       | The running time is a function    | Finding an element in a sorted    |
|                      |                | of the logarithm base 2 of the    | list using binary search.         |
|                      |                | input size.                       |                                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Linear               | O(n)           | The running time is directly      | Finding an element in an unsorted |
|                      |                | proportional to the input size.   | list.                             |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Linear Logarithmic   | O(n log n)     | The running time is a function of | Merge sort                        |
|                      |                | the linear times the logarithmic  |                                   |
|                      |                | function of the input size.       |                                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Quadratic            | O(n^2)         | The running time is a function of | A slower sorting algorithm like   |
|                      |                | the square of the input size.     | selection sort.                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Exponential          | O(2^n)         | The running time is an            | Optimized traveling salesman      |
|                      |                | exponential function of the input | problem.                          |
|                      |                | size.                             |                                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|

=Big-O= notation is sometimes insufficient or even misleading. Consider the following issues whenever you
think about =big-O= performance specifications:
- If an algorithm takes twice as long to work on twice as much data, it doesn't say anything about how long it
  took in the first place! If the algorithm is written badly but scales well, it's still not something you
  want to use. For example, suppose the algorithm makes unnecessary disk accesses. That probably wouldn't
  affect the =big-O= time but would be very bad for overall performance.
- Along those lines, it's difficult to compare two algorithms with the same =big-O= running time. For example,
  if two different sorting algorithms both claim to be =O(n log n)=, it's hard to tell which is really faster
  without running your own tests.
- The =big-O= notation describes the time complexity of an algorithm asymptotically, as the input size grows
  to infinity. For small inputs, =big-O= time can be very misleading. An =O(n^2)= algorithm might actually
  perform better than an =O(log n)= algorithm on small input sizes. Consider your likely input sizes before
  making a decision.

*** The Standard Library
C++ comes with a standard library, which contains a lot of useful classes that can easily be used in your
code. The benefit of using classes from the standard library is that you don't need to reinvent certain
classes and you don't need to waste time on implementing things that have already been implemented for you.
Another benefit is that the classes available in the standard library are heavily tested and verified for
correctness by thousands of users. The standard library classes are also tuned for high performance, so using
them will most likely result in better performance compared to making your own implementation.

When working with collections take great care of what you store in them. For example, if you return a
reference to an object in a collection from some method, it is recommended to not directly store objects in
the collection, but pointers or better yet smart pointers to objects, to avoid bizarre aliasing problems,
which can be hard to track down. For example, suppose a client stores a reference received by a call to a
method that return references from collections. If the collection directly stores objects, this returned
reference can become invalid when the collection needs to reallocate memory. Storing pointers or smart
pointers in the collection avoids this reference-invalidation problem
