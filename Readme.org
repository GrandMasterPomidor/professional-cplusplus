#+TITLE: Professional C++ Third Edition by Marc Gregoire

* Links
[[http://www.nuonsoft.com/blog/][Marc Gregoire's Blog]] |
[[http://www.cppreference.com][Cpp Reference (cppreference.com)]] |
[[http://www.cplusplus.com/reference/][Cpp Reference (cplusplus.com/reference)]] |
[[http://www.gnu.org][GNU Project]] |
[[http://www.opensource.org][Open Source Initiative]] |
[[http://www.boost.org][Open Source Boost Libraries]] |
[[http://www.sourceforge.net][Open Source Libraries]]

* Part I - Introduction to Professional C++
** Chapter 01 - A Crash Course in C++ and the STL
*** Notes
- A function declaration tells the compiler how a function is called, declaring the number and types of
  parameters, and the function return type. A definition contains the actual code for the function. In C++,
  declarations usually go into files with extension =.h=, known as =header files=, while definitions usually
  go into files with extension =.cpp=, known as =source files=. A lot of other programming languages do not
  separate declarations and definitions into separate files, for example =C#= and =Java=.
- In =C=, header files usually end in =.h= as =<stdio.h>=. In =C++=, the suffix is ommitted for standard
  library headers, such as =<iostream>. Standard headers from =C= still exist in =C++=, but with new names.
  For example, you can access the functionality from =<stdio.h>= by including =<cstdio>=.
- Namespaces address the problem of naming conflicts between different pieces of code.
- Most compilers will issue a warning or an error when code is using uninitialized variables. Some compilers
  will generate code that will report and error at run time.
- C++ does not provide a basic string type. However, a standard implementation of a string is provided as part
  of the standard library.
- Both C-style arrays and the =std::array=s have a fixed size, which should be known at compile time. They
  cannot grow or shrink at run time.
- Function declarations are often called "function prototypes" or "signatures" to emphasize that they
  represent how the function can be accessed, but not the code behind it.
- In C++, unlike C, a function that takes no parameters just has an empty parameter list. It is not necessary
  to use =void= to indicate that no parameters are taken. However, you must still use =void= to indicate when
  no value is returned.
- Avoid using =malloc()= and =free()= from C. Instead, use =new= and =delete=, or =new[]= and =delete[]=.
- Naked, plain old pointers are only allowed if there is no ownership involved. Otherwise, use =unique_ptr= by
  default, and =shared_ptr= if you need shared ownership. If you know about =auto_ptr=, forget it because the
  C++ standard has deprecated it.
- In C++ a class defines the characteristics of an object. Classes are usually defined in a header file
  (=.h=), while the definitions of its non-inline methods and of any static data members is in a corresponding
  source file (=.cpp=).
- To follow the const-correctness principle, it's always a good idea to declare member functions that do not
  change any data member of the object as being =const=. These member functions are also called "inspectors,"
  compared to "mutators" for non-const member functions.

*** Warnings
- Never put a =using= directive or =using= declaration in a header file, otherwise you force it on everyone
  that is including your header.
- In C++, the first element of an array is always at position 0, not position 1! The last position of the
  array is always the size of the array minus 1!
- A pointer must be valid before dereferencing it. A =null= or uninitialized pointer will cause a crash if
  dereferenced.
- To prevent memory leaks, every call to =new= should be paired with a call to =delete=, and every call to
  =new[]= should be paired with a call to =delete[]=. Pairing a =new[]= with a =delete= also causes a memory
  leak.

** Chapter 02 - Working with Strings
*** Notes
- C++ provides a much-improved implementation of the concept of a string as part of the Standard Library. In
  C++, =std::string= is a class (actually an instantiation of the =basic_string= class template) that supports
  many of the same functionalities as the =<cstring>= functions, but takes care of memory allocation for you.
  The string class is defined in the =<string>= header in the =std= namespace.
- Raw string literals are string literals that can span across multiple lines of code, that don't require
  escaping of embedded double quotes, and where escape sequences like =\t= and =\n= are not processed as
  escape sequences, but as normal text.

*** Warnings
- When starting a project in C++, it is very important to decide ahead of time how your group will represent
  strings.

** Chapter 03 - Coding with Style
*** Notes
- Commenting every line of code is usually untenable, but if the code is complicated enough to require it,
  don't just translate the code to English: explain what's really going on.
- Good code is naturally readable and only requires comments to provide useful additional information.
- Language features exist to help the programmer. Understand and make use of features that contribute to good
  programming style.

* Part II - Professional C++ Software Design
** Chapter 04 - Designing Professional C++ Programs
*** Notes
- The point of designing is to think about your program before you write it.
- Keep in mind that good design is hard, and getting it right takes practice. Don't expect to become an expert
  overnight, and don't be surprised if you find it more difficult to master C++ design than C++ coding.
- A program uses a library but fits into a framework. Libraries provide specific functionality, while
  frameworks are fundamental to your program design and structure.
- Although people use the terms API and library interchangeably, they are not equivalent. The library refers
  to the implementation, while the API refers to the published interface to the library.
- Big-O notation applies only to algorithms whose speed depends on their inputs. It does not apply to
  algorithms that take no input or whose runnign time is random. In practice, you will find that the running
  times of most algorithms of interest depend on their input, so this limitation is not significant.

*** Warnings
- Make sure that you understand the license restrictions of any third-party libraries you use if you plan to
  distribute or sell the code you develop. When in doubt, consult a legal expert.
- Due to time constraints, programmers sometimes find their prototypes morphing into the final product. If you
  have hacked together a prototype that is insufficient as the basis for the final product, make sure that it
  doesn't get used way.

** Chapter 05 - Designing with Objects
*** Notes
- Unlike the procedural approach, which is based on the question What does this program do?, the
  object-oriented approach asks another question: What real-world objects am I modeling? =OOP= is based on the
  notion that you should divide your program not into tasks, but into models of physical objects. While this
  seems abstract at first, it becomes clearer when you consider physical objects in terms of their =classes=,
  =components=, =properties=, and =behaviors=.
- The =Has-A Relationship=: Objects engaged in a =has-a=, or =aggregation=, relationship follow the pattern A
  has a B, or A contains a B. In this type of relationship, you can envision one object as part of another.
  Components generally represent a has-a relationship because they describe objects that are made up of other
  objects.
- The =Is-A Relationship= (Inheritance): The is-a relationship is such a fundamental concept of
  object-oriented programming that it has many names, including deriving, subclassing, extending, and
  inheriting. Classes model the fact that the real world contains objects with properties and behaviors.
  Inheritance models the fact that these objects tend to be organized in hierarchies. These hierarchies
  indicate is-a relationships. Fundamentally, inheritance follows the pattern A is a B or A is really quite a
  bit like B.
- A good object-oriented hierarchy accomplishes the following:
  - Organizes classes into meaningful functional relationships.
  - Supports code reuse by factoring common functionality to base classes.
  - Avoid having derived classes that override much of the parent's functionality, unless the parent is an
    abstract class.

** Chapter 06 - Designing for Reuse
*** Notes
- Unfortunately, C++ is fundamentally unfriendly to the principle of good abstraction when writing classes.
  The syntax requires you to combine your public interfaces and non-public (private or protected) data members
  and methods together in one class definition, thereby exposing some of the internal implementation details
  of the class to its clients. Chapter 8 describes some techniques for working around this in order to present
  clean interfaces.
- Always think about your interfaces from the perspective of someone using them. Do they make sense? Are they
  what you would expect?

**** Structuring your code
- Avoid combining unrelated or logically separate concepts: When you design a library or framework, keep it
  focused on a single task or group of tasks, i.e., strive for high cohesion.
- Divide your programs into logical subsystems: Design your subsystems as discrete components that can be
  reused independently, i.e., strive for low coupling.
- Use class hierarchies to separate logical concepts: In addition to dividing your program into logical
  subsystems, you should avoid combining unrelated concepts at the class level. You should also avoid
  combining unrelated concepts at the level of methods, just as you should do at the class level. Both at the
  class level and the method level you should strive for high cohesion.
- Use aggregation to separate logical concepts: Aggregation models the has-a relationship: Objects contain
  other objects to perform some aspects of their functionality. You can use aggregation to separate unrelated
  or related but separate functionality when inheritance is not appropriate.
- Eliminate user interface dependencies: If your library is a data manipulation library, you want to separate
  data manipulation from the user interface. This means that for those kinds of libraries you should never
  assume in which type of user interface the library will be used. As such, do not use =cout=, =cerr=, =cin=,
  =stdout=, =stderr=, or =stdin=, because if the library is used in the context of a graphical user interface
  these concepts may make no sense.
- Use templates for generic data structures and algorithms: C++ has a concept called templates allowing you to
  create structures that are generic with respect to a type or class. The notion of a template is that the
  type becomes a parameter to the specification, and you can create a single body of code that can work on any
  type. Templates allow you to write both data structures and algorithms that work on any types.
- Provide appropriate checks and safeguards: There are two opposite styles for writing safe code. The optimal
  programming style is probably using a healthy mix of both of them. The first is called design-by-contract
  which means that the documentation for a function or a class represents a contract with a detailed
  description of what the responsibility of the client code is and what the responsibility of your function or
  class is. This is often used in the =STL=. The second style is that you design your functions and classes to
  be as safe as possible. The most important aspect of this guideline is to perform error checking in your
  code.

**** Designing Interfaces
- Develop Easy-To-Use Interfaces: The best strategy for developing easy-to-use interfaces is to follow
  standard and familiar ways of doing things. When people encounter an interface similar to something they
  have used in the past, they will understand it better, adopt it more readily, and be less likely to use it
  improperly. Applied to C++, this strategy implies that you should develop interfaces that follow standards
  to which C++ programmers are accustomed. For example, C++ programmers expect the =constructor= and
  =destructor= of a class to initialize and clean up an object, respectively. When you design your classes,
  you should follow this standard. If you require programmers to call =initialize()= and =cleanup()= methods
  for initialization and cleanup instead of placing that functionality in the =constructor= and =destructor=,
  you will confuse everyone who tries to use your class. Because your class behaves differently from other C++
  classes, programmers will take longer to learn how to use it and will be more likely to use it incorrectly
  by forgetting to call =initialize()= or =cleanup()=.
- Don't omit required functionality: First, include interfaces for all behaviors that clients could need. This
  strategy requires you to anticipate all the uses to which clients might put your code. If you are thinking
  about the interface in one particular way, you might miss functionality that could be needed when clients
  use it differently. The second part of this strategy is to include as much functionality in the
  implementation as possible. Don't require client code to specify information that you already know in the
  implementation, or could know if you designed it differently.
- Present uncluttered interfaces: Don't provide unnecessary functionality in your interfaces; keep them clean
  and simple. It might appear at first that this guideline directly contradicts the previous strategy of
  avoiding omitting necessary functionality. Although one strategy to avoid omitting functionality would be to
  include every imaginable interface, that is not a sound strategy. You should include necessary functionality
  and omit useless or counterproductive interfaces.
- Provide documentation and comments: Regardless of how easy to use you make your interfaces, you should
  supply documentation for their use. There are two ways to provide documentation for your interfaces:
  comments in the interfaces themselves and external documentation. You should strive to provide both. Whether
  you provide comments, external documentation, or both, the documentation should describe the behavior of the
  library, not the implementation. The behavior includes the inputs, outputs, error conditions and handling,
  intended uses, and performance guarantees.
- Provide multiple ways to perform the same functionality: In order to satisfy all your "customers," it is
  sometimes helpful to provide multiple ways to perform the same functionality. Use this technique
  judiciously, however, because over application can easily lead to cluttered interfaces.
- Provide customizability: In order to increase the flexibility of your interfaces, provide customizability.
  Customizability can be as simple as allowing a client to turn on or off error logging. The basic premise of
  customizability is that it allows you to provide the same basic functionality to every client, but gives
  clients the ability to tweak it slightly.
- Make common functionality easy to use: When you provide a general-purpose interface, some functionality will
  be used more often than other functionality. You should make the commonly used functionality easy to use,
  while still providing the option for the more advanced functionality.

*** Warnings
- When designing your interface, do not expose implementation details to your clients.

* Part III - Coding The Professional Way
** Chapter 07 - Gaining Proficiency with Classes and Objects
*** Notes
- A =class definition= is a statement in C++, so it must end with a semicolon. If you fail to terminate your
  =class definition= with a semicolon, your compiler will probably give you several errors, most of which will
  appear to be completely unrelated.
- A =class= can have a number of members. A member is either a member function (which in turn is either a
  method, constructor, or destructor), or a member variable also called data member.
- In C++, a =struct= can have methods just like a =class=. In fact, the only difference is that the default
  access specifier for a =struct= is =public= while the default for a =class= is =private=.
- Every normal method call passes a pointer to the object for which it is called as a "hidden" parameter with
  the name =this=. You can use this pointer to access data members or call methods, and can pass it to other
  methods or functions. It is also sometimes useful for disambiguating names. if =this= is a pointer to the
  object on which a method executes, then =*this= is the object itself!
- If you don't use =smart pointers=, it is always a good idea to reset a pointer to the =null pointer= after
  deleting the object to which it pointed. You are not required to do this, but it will make debugging easier
  in case the pointer is accidentally used after deleting the object.
- The object life cycle involves three activities: creation, destruction, and assignment. It is important to
  understand how and when objects are created, destroyed, and assigned, and how you can customize these
  behaviors.
- C++ supports delegating constructors which allow you to call other constructors from the same class from
  inside the =ctor-initializer=.
- There is a special constructor in C++ called a copy constructor that allows you to create an object that is
  an exact copy of another object. If you don't write a copy constructor yourself, C++ generates one for you
  that initializes each data member in the new object from its equivalent data member in the source object.
  For object data members, this initialization means that their copy constructors are called.
- For performance reasons, it is best to pass objects by =const= reference instead of by value.
- The assignment operator is sometimes called the copy assignment operator because both the left-hand side and
  the right-hand side object stay alive after the assignment. This distinction is made because there is also a
  move assignment operator in which the right-hand side object will be destroyed after the assignment for
  performance reasons.
- In the world of C++, "copying" only occurs when an object is being initialized. If an object already has a
  value that is being overwritten, the more accurate term is "assigned" to. Note that the facility that C++
  provides for copying is the copy constructor. Since it is a constructor, it can only be used for object
  creation, not for later assignments to the object. Therefore, C++ provides another method in every class to
  perform assignment. This method is called the assignment operator. Its name is operator= because it is
  actually an overloading of the = operator for that class.
- The implementation of the assignment operator is similar to that of a copy constructor, with several
  important differences. First, a copy constructor is called only for initialization, so the destination
  object does not yet have valid values. An assignment operator can overwrite the current values in an object.
  This consideration doesn't really come into play until you have dynamically allocated memory in your
  objects. Second, it's legal in C++ to assign an object to itself. Your assignment operator shouldn't
  prohibit self-assignment, but also shouldn't perform a full assignment if it happens. Thus, assignment
  operators should check for self-assignment at the beginning of the method and return immediately.

*** Warnings
- If you allocate an object with =new=, free it with =delete= when you are finished with it, or use =smart
  pointers= to manage the memory automatically.
- When creating an object on the stack, omit parentheses for the default constructor.
- If you don't specify any constructors, the compiler will write one for you that doesn't take any arguments.
  This =compiler-generated default constructor= calls the default constructor on all object members of the
  class, but does not initialize the language primitives such as =int= and =double=. Nonetheless, it allows
  you to create objects of that class. However, if you declare a default constructor, or any other
  constructor, the compiler no longer generates a default constructor for you.
- A =default constructor= is the same thing as a 0-argument constructor. The term =default constructor= does
  not refer only to the constructor automatically generated if you fail to declare any constructors. It refers
  to the constructor which is defaulted to if no arguments are required.
- Ctor-initializers allow initialization of data members at the time of their creation. Ctor-initializers
  initialize data members in the order that they appear in the class definition, not their order in the
  ctor-initializer.
- Make sure you always free dynamically allocated memory by calling =delete= or =delete[]= depending on
  whether the memory was allocated using =new= or =new[]= or better yet, use smart pointers.
- You could actually declare the assignment operator to return whatever type you wanted, including =void=.
  However, you should always return a reference to the object on which it is called because that's what
  clients expect.

** Chapter 08 - Mastering Classes and Objects
*** Notes

*** Warnings

** Chapter 09 - Discovering Inheritance Techniques
*** Notes
*** Warnings
** Chapter 10 - C++ Quirks, Oddities, and Incidentals
*** Notes
*** Warnings
** Chapter 11 - Writing Generic Code with Templates
*** Notes
*** Warnings
** Chapter 12 - Demystifying C++ I/O
*** Notes
*** Warnings
** Chapter 13 - Handling Errors
*** Notes
*** Warnings
** Chapter 14 - Overloading C++ Operators
*** Notes
*** Warnings
** Chapter 15 - Overview of the C++ Standard Library
*** Notes
*** Warnings
** Chapter 16 - Understanding Containers and Iterators
*** Notes
*** Warnings
** Chapter 17 - Mastering STL Algorithms
*** Notes
*** Warnings
** Chapter 18 - String Localization and Regular Expressions
*** Notes
*** Warnings
** Chapter 19 - Additional Library Utilities
*** Notes
*** Warnings
* Part IV - Mastering Advanced Features of C++
** Chapter 20 - Customizing and Extending the STL
*** Notes
*** Warnings
** Chapter 21 - Advanced Templates
*** Notes
*** Warnings
** Chapter 22 - Memory Management
*** Notes
*** Warnings
** Chapter 23 - Multithreaded Programming with C++
*** Notes
*** Warnings
* Part V - C++ Software Engineering
** Chapter 24 - Maximizing Software Engineering Methods
*** Notes
*** Warnings
** Chapter 25 - Writing Efficient C++
*** Notes
*** Warnings
** Chapter 26 - Conquering Debugging
*** Notes
*** Warnings
* Appendix A - C++ Interviews
* Appendix B - Annotated Bibliography
* Appendix C - Standard Library Header Files

* Stuff
** The =const= keyword
The keyword =const= is short for "constant" and specifies that something remains unchanged. The compiler will
enforce this requirement by marking any attempt to change it as an error. Furthermore, when optimizations are
enabled, the compiler can take advantage of this knowledge to produce better code. The keyword has two related
roles. It can mark variables or parameters, and it can mark methods.

*** =const= Variables and Parameters
You can use =const= to "protect" variables by specifying that they cannot be modified. You can mark any
variable =const=, including global variables and class data members. Defining a constant with =const= is just
like defining a variable, except that the compiler guarantees that code cannot change the value.
#+BEGIN_SRC c++
  const double PI = 3.141592653589793238462;
  const std::string productName = "Super Hyper Net Modulator";
#+END_SRC

You can also use =const= to specify that parameters to functions or methods should remain unchanged.
#+BEGIN_SRC c++
  void mysteryFunction(const std::string* someString) {
    *someString = "Test"; // Will not compile
  }
#+END_SRC

**** =const= Pointers
#+BEGIN_SRC c++
  int const* ip; // Same as const int* ip;
  ip = new int[10];
  ip[4] = 5; // DOES NOT COMPILE! (Cannot change the value to wich ip points)

  int* const ip = nullptr; // mark ip itself const (not the values to which it points)
  ip = new int[10];        // DOES NOT COMPILE!
  ip[4] = 5;               // Error: dereferencing a null pointer

  int* const ip = new int[10]; // OK
  ip[4] = 5;                   // OK
  ip = new int[20];            // DOES NOT COMPILE!

  int const* const ip = nullptr; // both the pointer and the values to which it points are const
#+END_SRC

**** =const= References
=const= applied to references is usually simpler than =const= applied to pointers for two reasons. First,
references are =const= by default, in that you can't change to what they refer. So, there is no need to mark
them =const= explicitly. Second, you can't create a reference to a reference, so there is usually only one
level of indirection with references. The only way to get multiple levels of indirection is to create a
reference to a pointer.
#+BEGIN_SRC c++
  int z;
  int const& zRef = z; // Same as: const int& zRef = z;
  zRef = 4; // DOES NOT COMPILE!
#+END_SRC

By passing a const reference you ensure that no copy is made but the original variable cannot be changed.
#+BEGIN_SRC c++
  void printString(const std::string& someString) {
    std::cout << someString << std::endl;
  }
#+END_SRC

*** =const= Methods
You can mark a class method =const=, which prevents the method from modifying any non-mutable data members of
the class.

*** The =constexpr= Keyword
Constant expressions are evaluated at compile time.
#+BEGIN_SRC c++
  const int getArraySize() { return 32; }
  int main() {
    int myArray[getArraySize()]; // Invalid in C++
    return 0;
  }

  constexpr int getArraySize() { return 32; }
  int main() {
    int myArray[getArraySize()]; // OK
    int mySecondArray[getArraySize() + 5]; // OK
    return 0;
  }
#+END_SRC

Declaring a function as =constexpr= imposes quite a lot of restrictions on what the function can do because
the compiler has to be able to evaluate the function at compile time, and the function is not allowed to have
any side effects. Here are a couple of restrictions:
- The function body shall be a single return statement that does not contain a =goto= statement or a try catch
  block, and does not throw any exceptions. It is allowed to call other =constexpr= functions.
- The return type of the function shall be a literal type. It cannot be =void=.
- If the =constexpr= function is a member of a class, the function cannot be =virtual=.
- All the function arguments shall be literal types.
- A =constexpr= function cannot be called until it's defined in the translation unit because the compiler
  needs to know the complete definition.
- =dynamic_cast= is not allowed.
- =new= and =delete= are not allowed.

By defining a =constexpr= constructor you can create constant expression variables of user-defined types. A
=constexpr= constructor should satisfy the following requirements:
- All the constructor arguments should be literal types.
- The constructor body cannot be a function-try-block.
- The constructor body should satisfy the same requirements as the body of a =constexpr= function.
- All data members should be initialized with constant expressions.
#+BEGIN_SRC c++
  class Rect {
  public:
    constexpr Rect(int width, int height) : mWidth(width), mHeight(height) {}
    constexpr int getArea() const { return mWidth * mHeight; }
  private:
    int mWidth, mHeight;
  };

  int main() {
    constexpr Rect r(8, 2);
    int myArray[r.getArea()]; // OK
    return 0;
  }
#+END_SRC

** Type Inference
Type inference allows the compiler to automatically deduce the type of an expression. There are two keywords
for type inference: =auto= and =decltype= and C++14 add =decltype(auto)=.

*** The =auto= keyword
The =auto= keyword has four completely different meanings:
  1. The first meaning is to tell the compiler to automatically deduce the type of a variable at compile time.
  2. The second use of the =auto= keyword is for the =alternative function syntax=.
  3. The third use of the =auto= keyword is for =function return type deduction=
  4. The fourth use of =auto= is for generic lambda expressions.

*** The =decltype= keyword
The =decltype= keyword takes an expression as argument, and computes the type of that expression. For example:
#+BEGIN_SRC C++
  int x = 123;
  decltype(x) y = 456; // The compiler deduces the type of y to be int because that's the type of x
#+END_SRC

*** =decltype(auto)=
Using =auto= to deduce the type of an expression strips away reference qualifiers and const qualifiers.
=decltype= does not strip those, but might cause code duplication. C++14 solves this by introducing
=decltype(auto)=.
#+BEGIN_SRC c++
  const string message = "Test";
  const string& foo() { return message; }

  auto f1 = foo();            // f1 is of type string and thus a copy is made.
  const auto& f1 = foo();     // explicitely make it a reference and mark it const.
  decltype(foo()) f1 = foo(); // f1 is of type const string& but the syntax is ugly.
  decltype(auto) f1 = foo();  // f1 is of type const string&.
#+END_SRC

** Smart Pointers
To avoid common memory problems, you should use smart pointers instead of normal "naked" C-style pointers.
Smart pointers automatically deallocate memory when the smart pointer object goes out of scope, for example
when the function has finished executing.

The difference between =shared_ptr= and =unique_ptr= is that =shared_ptr= is a reference-counted smart
pointer, while =unique_ptr= is not reference counted. This means that you can have several =shared_ptr=
instances pointing to the same dynamically allocated memory and the memory will only be deallocated when the
last =shared_ptr= goes out of scope. =shared_ptr= is also thread-safe.

=unique_ptr= on the other hand means ownership. When the single =unique_ptr= goes out of scope, the underlying
memory is freed. Your default smart pointer should be =unique_ptr=. Use only =shared_ptr= when you need to
share the resource.

*** std::unique_ptr
The =unique_ptr= is analogous to an ordinary pointer, except that it will automatically free the memory or
resource when the =unique_ptr= goes out of scope or is deleted. A =unique_ptr= has sole ownership of the
object pointed to.

=unique_ptr= does not support the normal copy assignment operator and copy constructor, but it does support
the move assignment operator and move constructor, which explains why you can return a =unique_ptr= from a
function.

#+BEGIN_SRC C++
  Employee *emp = new Employee;               // normal "naked" pointer
  auto emp = std::make_unique<Employee>();    // std::unique_ptr smart pointer (C++14)
  std::unique_ptr<Employee> emp(new Employee) // std::unique_ptr smart pointer (C++11)

  auto p1 = std::make_unique<int>(42);
  std::unique_ptr<int> p2 = p1;              // Error: does not compile. No copy constructor.
  std::unique_ptr<int> p3 = std::move(p1);   // OK. Ownership has been moved from p1 to p3.
#+END_SRC

*** std::shared_ptr
=shared_ptr= allows for distributed "ownership" of data. Each time a =shared_ptr= is assigned, a reference
count is incremented indicating there is one more "owner" of the data. When a =shared_ptr= goes out of scope,
the reference count is decremented. When the reference count goes to zero it means there is no longer any
owner of the data, and the object referenced by the pointer is freed. You can't store an array in a
=shared_ptr=.

=const_pointer_cast()=, =dynamic_pointer_cast()=, and =static_pointer_cast()= are functions available to cast
=shared_ptrs=.

#+BEGIN_SRC c++
  auto emp = std::make_shared<Employee>();    // std::shared_ptr smart pointer (C++14)
  std::shared_ptr<Employee> emp(new Employee) // std::shared_ptr smart pointer (C++11)

  std::shared_ptr<Base> myBasePtr(new Derived);
  std::shared_ptr<Derived> myDerivedPtr = std::dynamic_pointer_cast<Derived>(myBasePtr);
#+END_SRC

*** std::weak_ptr
You can use a =weak_ptr= to observe a =shared_ptr= without incrementing or decrementing the reference count of
the linked =shared_ptr=.

A =weak_ptr= can contain a reference to memory managed by a =shared_ptr=. The =weak_ptr= does not own the
memory, so the =shared_ptr= is not prevented from deallocating the memory. A =weak_ptr= does not destroy the
pointed to memory when it goes out of scope; however, it can be used to determine if the memory has been
deallocated by the associated =shared_ptr= or not. The constructor of a =weak_ptr= requires a =shared_ptr= or
another =weak_ptr= as argument. To get access to the pointer stored in a =weak_ptr= you need to convert it to
a =shared_ptr=. There are two ways to do this:
  - Use the =lock()= method on a =weak_ptr= instance, which returns a =shared_ptr=.
  - Create a new =shared_ptr= instance and give a =weak_ptr= as argument to the =shared_ptr= constructor.
In both cases, this new =shared_ptr= will be =nullptr= if the =shared_ptr= associated with the =weak_ptr= has
been deallocated in the meantime.

** Access Specifiers
| Specifier | Meaning                                      | When to Use                                        |
|-----------+----------------------------------------------+----------------------------------------------------|
| public    | Any code can call public member function     | Behaviors (methods) that you want clients to use.  |
|           | or access a public data member of an object. | Access methods for private and protected data      |
|           |                                              | members.                                           |
|-----------+----------------------------------------------+----------------------------------------------------|
| protected | Any member function of the class can call    | "Helper" methods that you don not want clients     |
|           | protected member functions and access        | to use.                                            |
|           | protected data members. Member functions of  |                                                    |
|           | derived class can access protected members   |                                                    |
|           | of a base class.                             |                                                    |
|-----------+----------------------------------------------+----------------------------------------------------|
| private   | Only members functions of the class can call | Everything should be private by default,           |
|           | private member functions and access private  | especially data members. You can provide protected |
|           | data members. Member functions in derived    | getters and setters if you only want to allow      |
|           | classes cannot access private members from   | derived classes access them, and provide public    |
|           | a base class.                                | getters and setters if you want clients to access  |
|           |                                              | them.                                              |
|-----------+----------------------------------------------+----------------------------------------------------|

** Constructors and Destructors
*** Summary of Compiler-Generated Constructors
The compiler automatically generates a 0-argument and copy constructor for every class. However, the
constructors you define yourself replace these according to the following rules:

| If you define...         | ...then the compiler generates... | ...and you can create an object...          |
|--------------------------+-----------------------------------+---------------------------------------------|
| [no constructors]        | A 0-argument constructor          | With no arguments:                          |
|                          | A copy constructor                | =SpreadsheetCell cell;=                     |
|                          |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell myCell(cell);=             |
|--------------------------+-----------------------------------+---------------------------------------------|
| A 0-argument             | A copy constructor                | With no arguments:                          |
| constructor only         |                                   | =SpreadsheetCell cell;=                     |
|                          |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell myCell(cell);=             |
|--------------------------+-----------------------------------+---------------------------------------------|
| A copy constructor       | No constructors                   | Theoretically, as a copy of another object. |
| only                     |                                   | Practically, you can't create any objects.  |
|--------------------------+-----------------------------------+---------------------------------------------|
| A single-argument or     | A copy constructor                | With arguments:                             |
| multi-argument non-      |                                   | =SpreadsheetCell cell(6);=                  |
| copy constructor only    |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell myCell(cell);=             |
|--------------------------+-----------------------------------+---------------------------------------------|
| A 0-argument constructor | A copy constructor                | With no arguments:                          |
| as well as a single-     |                                   | =SpreadsheetCell cell;=                     |
| argument or multi-       |                                   | With arguments:                             |
| argument non-copy        |                                   | =SpreadsheetCell myCell(5);=                |
| constructor              |                                   | As a copy of another object:                |
|                          |                                   | =SpreadsheetCell anotherCell(cell);=        |
|--------------------------+-----------------------------------+---------------------------------------------|

Note the lack of symmetry between the default constructor and the copy constructor. As long as you don't
define a copy constructor explicitly, the compiler creates one for you. On the other hand, as soon as you
define any constructor, the compiler stops generating a default constructor. As mentioned before in this
chapter, the automatic generation of a default constructor and a default copy constructor can be influenced by
defining them as explicitly defaulted or explicitly deleted.

*** Constructor Order
Objects don't spring to live all at once; they must be constructed along with their parents and any objects
that are contained within them. C++ defines the creation order as follows:

1. If the class has a base class, the default constructor of the base class is executed, unless there is a
   call to a base class constructor in the ctor-initializer in which case that constructor is called instead
   of the default constructor.
2. Non-static data members of the class are constructed in the order in which they are declared.
3. The body of the class's constructor is executed.

These rules can apply recursively. If the class has a grandparent, the grandparent is initialized before the
parent, and so on.

*** Destructor Order
Because destructors cannot take arguments, the language can always automatically call the destructor for
parent classes. The order of destruction is conveniently the reverse of the order of construction:

1. The body of the class's destructor is called.
2. Any data members of the class are destroyed in the reverse order of their construction.
3. The parent class, if any, is destructed.

Again, these rules apply recursively. The lowest member of the chain is always destructed first.

** Rule of Six
- Default Constructor
- Copy Constructor
- Move Constructor (C++11 or higher)
- Copy Assignment Operator
- Move Assignment Operator (C++11 or higher)
- Destructor (Should be virtual)

#+BEGIN_SRC c++
  Spreadsheet();                             // ctor
  Spreadsheet(const Spreadsheet& src);       // copy ctor
  Spreadsheet(Spreadsheet&& src) noexcept;   // move ctor
  virtual ~Spreadsheet();                    // destructor

  Spreadsheet& operator=(const Spreadsheet& rhs);      // assignment operator
  Spreadsheet& operator=(Spreadsheet&& rhs) noexcept;  // move assignment operator
#+END_SRC

C++ has six methods (four in C++03) with a default behavior. The code for those can be generated by the
compiler - saving us from boring routine work and thus preventing oversights. Regarding the six operations,
implement as little as possible and declare as much as possible. Any operation not implemented shall be
declared as =default= or =delete=.

Move semantics for objects requires a move constructor and a move assignment operator. These will be used by
the compiler on places where the source object is a temporary object that will be destroyed after the copy or
assignment. Both the move constructor and the move assignment operator copy/move the member variables from the
source object to the new object and then reset the variables of the source object to null values. By doing
this, they are actually moving ownership of the memory from one object to another object. They basically do a
shallow copy of the member variables and switch ownership of allocated memory to prevent dangling pointers or
memory leaks.

Move semantics is implemented by using rvalue references. To add move semantics to a class, a move constructor
and a move assignment operator need to be implemented. Move constructors and move assignment operators should
be marked with the =noexcept= qualifier to tell the compiler that they don't throw any exceptions. This is
particularly important for compatibility with the standard library, as fully compliant implementations of the
standard library will only move stored objects if, having move semantics implemented, they also guarantee not
to throw.

Obviously, move semantics is useful only when you know that the source object will be destroyed.

** Exceptions
An exception is an unexpected situation. Exceptions come with some new terminology. When a piece of code
detects an exceptional situation, it =throws= an exception. Another piece of code =catches= the exception and
takes appropriate action. Exceptions can get tricky in C++. To use exceptions properly, you need to understand
what happens to the stack variables when an exception is thrown, and you have to be careful to properly catch
and handle the necessary exceptions. Unlike the Java language, the C++ compiler doesn't force you to catch
every exception that might occur. If your code never catches any exceptions but an exception is thrown, it
will be caught by the program itself, which will be terminated.

** Big-O Notation
=Big-O= notation specifies algorithm run time as a function of its input size, also known as the complexity of
the algorithm. For example, an algorithm with a performance that is linear as a function of its input size
takes twice as long to process twice as many elements. Thus, if it takes 2 seconds to process 500 elements, it
will take 4 seconds to process 1000 elements. That is, you could graph the performance versus input size as a
straight line. =Big-O= notation summarizes the algorithm performance like this: =O(n)=. The =O= just means
that you're using =big-O= notation, while the =n= represents the input size. =O(n)= specifies that the
algorithm speed is a direct linear function of the input size.

| Algorithm Complexity | Big-O Notation | Explanation                       | Example Algorithms                |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Constant             | O(1)           | Running time is independent of    | Accessing a single element in an  |
|                      |                | input size.                       | array.                            |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Logarithmic          | O(log n)       | The running time is a function    | Finding an element in a sorted    |
|                      |                | of the logarithm base 2 of the    | list using binary search.         |
|                      |                | input size.                       |                                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Linear               | O(n)           | The running time is directly      | Finding an element in an unsorted |
|                      |                | proportional to the input size.   | list.                             |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Linear Logarithmic   | O(n log n)     | The running time is a function of | Merge sort                        |
|                      |                | the linear times the logarithmic  |                                   |
|                      |                | function of the input size.       |                                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Quadratic            | O(n^2)         | The running time is a function of | A slower sorting algorithm like   |
|                      |                | the square of the input size.     | selection sort.                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|
| Exponential          | O(2^n)         | The running time is an            | Optimized traveling salesman      |
|                      |                | exponential function of the input | problem.                          |
|                      |                | size.                             |                                   |
|----------------------+----------------+-----------------------------------+-----------------------------------|

=Big-O= notation is sometimes insufficient or even misleading. Consider the following issues whenever you
think about =big-O= performance specifications:
- If an algorithm takes twice as long to work on twice as much data, it doesn't say anything about how long it
  took in the first place! If the algorithm is written badly but scales well, it's still not something you
  want to use. For example, suppose the algorithm makes unnecessary disk accesses. That probably wouldn't
  affect the =big-O= time but would be very bad for overall performance.
- Along those lines, it's difficult to compare two algorithms with the same =big-O= running time. For example,
  if two different sorting algorithms both claim to be =O(n log n)=, it's hard to tell which is really faster
  without running your own tests.
- The =big-O= notation describes the time complexity of an algorithm asymptotically, as the input size grows
  to infinity. For small inputs, =big-O= time can be very misleading. An =O(n^2)= algorithm might actually
  perform better than an =O(log n)= algorithm on small input sizes. Consider your likely input sizes before
  making a decision.

** The Standard Library
C++ comes with a standard library, which contains a lot of useful classes that can easily be used in your
code. The benefit of using classes from the standard library is that you don't need to reinvent certain
classes and you don't need to waste time on implementing things that have already been implemented for you.
Another benefit is that the classes available in the standard library are heavily tested and verified for
correctness by thousands of users. The standard library classes are also tuned for high performance, so using
them will most likely result in better performance compared to making your own implementation.

When working with collections take great care of what you store in them. For example, if you return a
reference to an object in a collection from some method, it is recommended to not directly store objects in
the collection, but pointers or better yet smart pointers to objects, to avoid bizarre aliasing problems,
which can be hard to track down. For example, suppose a client stores a reference received by a call to a
method that return references from collections. If the collection directly stores objects, this returned
reference can become invalid when the collection needs to reallocate memory. Storing pointers or smart
pointers in the collection avoids this reference-invalidation problem
